package visitor;

import ast.*;
import ast.Package;
import ast.expr.BooleanExpr;
import ast.expr.DeclarationExpr;
import ast.expr.Expression;
import ast.java.FieldDeclaration;
import ast.stmt.*;
import ast.toplevel.*;
import ast.types.*;
import misc.Tuple;
import misc.Tuple1;
import misc.Tuple2;
import org.objectweb.asm.Opcodes;
import parser.ProcessJBaseVisitor;
import parser.ProcessJParser;
import typesystem.*;

import java.util.ArrayList;
import java.util.List;

import static misc.ConfigureAST.configureNode;


/**
 * Builds the AST from the parse tree generated by antlr4.
 *
 * @author Ben
 */
public class AstBuilder extends ProcessJBaseVisitor<Object> {

  private ArrayType getParentArray(ArrayType array) {
    while (!array.isOrphan()) {
      array = (ArrayType) array.getParentNode().get();
    }
    return array;
  }

  private ASTType createASTType(Type type) {
    if (type.isPrimitiveType()) {
      Primitive primitive = type.asPrimitiveType();
      PrimitiveNode primitiveNode = configureNode(new PrimitiveNode(), primitive);
      if (primitive.isByteType()) {
        primitiveNode.setTSType(primitive.asByteType());
      } else if (primitive.isIntegerType()) {
        primitiveNode.setTSType(primitive.asIntegerType());
      } else if (primitive.isShortType()) {
        primitiveNode.setTSType(primitive.asShortType());
      } else if (primitive.isBooleanType()) {
        primitiveNode.setTSType(primitive.asBooleanType());
      } else if (primitive.isLongType()) {
        primitiveNode.setTSType(primitive.asLongType());
      } else if (primitive.isFloatType()) {
        primitiveNode.setTSType(primitive.asFloatType());
      } else if (primitive.isDoubleType()) {
        primitiveNode.setTSType(primitive.asDoubleType());
      } else if (primitive.isCharType()) {
        primitiveNode.setTSType(primitive.asCharType());
      } else if (primitive.isTimerType()) {
        primitiveNode.setTSType(primitive.asTimerType());
      } else if (primitive.isBarrierType()) {
        primitiveNode.setTSType(primitive.asBarrierType());
      } else if (primitive.isStringType()) {
        primitiveNode.setTSType(primitive.asStringType());
      }
      return primitiveNode;
    } else if (type.isConstructedType()) {
      Constructed constructed = type.asConstructedType();
      if (constructed.isArrayType()) {
        ArrayType arrayType = constructed.asArrayType();
        ArrayNode arrayNode = configureNode(new ArrayNode(), arrayType);
        return arrayNode.setTSType(arrayType);
      } else if (constructed.isChannelType()) {
        ChannelType channelType = constructed.asChannelType();
        ChannelNode channelNode = configureNode(new ChannelNode(), channelType);
        return channelNode.setTSType(channelType);
      } else if (constructed.isChannelEndType()) {
        ChannelEndType channelEndType = constructed.asChannelEndType();
        ChannelEndNode channelEndNode = configureNode(new ChannelEndNode(), channelEndType);
        return channelEndNode.setTSType(channelEndType);
      } else if (constructed.isTypeVariable()) {
        TypeVariable typeVariable = constructed.asTypeVariable();
        ConstructedNode constructedNode = configureNode(new ConstructedNode(), typeVariable);
        return constructedNode.setTSType(typeVariable);
      }
      // types like protocol and record are resolved elsewhere
    }
    return null;
  }

  @Override
  public Object visitCompilationUnit(ProcessJParser.CompilationUnitContext ctx) {
    Package _package;
    if (ctx.packageDeclaration() != null) {
      _package = visitPackageDeclaration(ctx.packageDeclaration());
    }
    Sequence<Import> imports = Sequence.sequenceList();
    ctx.importDeclaration().forEach(i -> imports.add(visitImportDeclaration(i)));
    Sequence<TopLevelDeclaration<?>> typeDecls = Sequence.sequenceList();
    ctx.typeDeclaration().forEach(t -> typeDecls.add(visitTypeDeclaration(t)));
    return null;
  }

  @Override
  public Package visitPackageDeclaration(ProcessJParser.PackageDeclarationContext ctx) {
    Package _package = new Package(visitPackageName(ctx.packageName()));
    return configureNode(_package, ctx);
  }

  @Override
  public Name visitPackageName(ProcessJParser.PackageNameContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    if (ctx.packageName() != null) {
      name.setQualifier(visitPackageName(ctx.packageName()));
    }
    return name;
  }

  @Override
  public Import visitImportDeclaration(ProcessJParser.ImportDeclarationContext ctx) {
    if (ctx.singleStaticImportDeclaration() != null) {
      return visitSingleTypeImportDeclaration(ctx.singleTypeImportDeclaration());
    }
    if (ctx.singleTypeMultiImportDeclaration() != null) {
      return visitSingleTypeMultiImportDeclaration(ctx.singleTypeMultiImportDeclaration());
    }
    if (ctx.singleStaticMultiImportDeclaration() != null) {
      return visitSingleStaticImportDeclaration(ctx.singleStaticImportDeclaration());
    }
    return visitSingleStaticMultiImportDeclaration(ctx.singleStaticMultiImportDeclaration());
  }

  @Override
  public Name visitTypeName(ProcessJParser.TypeNameContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    if (ctx.typeName() != null) {
      name.setQualifier(visitTypeName(ctx.typeName()));
    }
    return name;
  }

  @Override
  public Import visitSingleTypeImportDeclaration(ProcessJParser.SingleTypeImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    if (ctx.DCOLON() != null) {
      _import.setFieldName(ctx.Identifier().getText());
    }
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitSingleTypeMultiImportDeclaration(ProcessJParser.SingleTypeMultiImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    _import.setStar(true);
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitSingleStaticImportDeclaration(ProcessJParser.SingleStaticImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    if (ctx.DOT() != null) {
      _import.setFieldName(ctx.Identifier().getText());
    }
    _import.setJavaImport(true);
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitSingleStaticMultiImportDeclaration(ProcessJParser.SingleStaticMultiImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    _import.setStar(true);
    _import.setJavaImport(true);
    return configureNode(_import, ctx);
  }

  @Override
  public TopLevelDeclaration<?> visitTypeDeclaration(ProcessJParser.TypeDeclarationContext ctx) {
    if (ctx.procedureTypeDeclaration() != null) {
      return visitProcedureTypeDeclaration(ctx.procedureTypeDeclaration());
    }
    if (ctx.recordTypeDeclaration() != null) {
      return visitRecordTypeDeclaration(ctx.recordTypeDeclaration());
    }
    if (ctx.protocolTypeDeclaration() != null) {
      return visitProtocolTypeDeclaration(ctx.protocolTypeDeclaration());
    }
    if (ctx.constantDeclaration() != null) {
      return visitConstantDeclaration(ctx.constantDeclaration());
    }
    return null;
  }

  @Override
  public ProcedureTopLevel visitProcedureTypeDeclaration(ProcessJParser.ProcedureTypeDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    ASTType type = visitType_(ctx.type_());
    final String identifier = ctx.Identifier().getText();
    Sequence<Parameter> parameters = Sequence.sequenceList();
    if (ctx.formarlParameterList() != null) {
      parameters.addAll(visitFormarlParameterList(ctx.formarlParameterList()));
    }
    BlockStmt body = null;
    ProcedureTopLevel procedure = new ProcedureTopLevel();
    procedure.setModifiers(modifiers);
    procedure.setASTType(type);
    procedure.setName(identifier);
    procedure.setParameters(parameters);
    procedure.setBody(body);
    return configureNode(procedure, ctx);
  }

  @Override
  public Integer visitModifier(ProcessJParser.ModifierContext ctx) {
    if (ctx.PRIVATE() != null) {
      return Opcodes.ACC_PRIVATE;
    }
    if (ctx.PROTECTED() != null) {
      return Opcodes.ACC_PROTECTED;
    }
    if (ctx.CONST() != null) {
      return Opcodes.ACC_FINAL;
    }
    if (ctx.NATIVE() != null) {
      return Opcodes.ACC_NATIVE;
    }
    return Opcodes.ACC_PRIVATE;
  }

  @Override
  public ASTType visitType_(ProcessJParser.Type_Context ctx) {
    if (ctx.primitiveType() != null) {
      Primitive type = visitPrimitiveType(ctx.primitiveType());
      return configureNode(new PrimitiveNode(type), ctx);
    } else if (ctx.referenceType() != null) {
      Type type = visitReferenceType(ctx.referenceType());
      if (type.isConstructedType()) {
        Constructed ctr = type.asConstructedType();
        if (ctr.isArrayType()) {
          return configureNode(new ArrayNode(ctr.asArrayType()), ctx);
        } else if (ctr.isChannelType()) {
          return configureNode(new ChannelNode(ctr.asChannelType()), ctx);
        } else if (ctr.isChannelEndType()) {
          return configureNode(new ChannelEndNode(ctr.asChannelEndType()), ctx);
        } else if (ctr.isTypeVariable()) {
          return configureNode(new ConstructedNode(ctr.asTypeVariable()), ctx);
        }
      }
    } else if (ctx.classType() != null) {
      // TODO: this is for when a Java class is used
    }
    VoidType type = configureNode(new VoidType(), ctx);
    return configureNode(new VoidNode(type), ctx);
  }


  @Override
  public Primitive visitPrimitiveType(ProcessJParser.PrimitiveTypeContext ctx) {
    if (ctx.numericType() != null) {
      return visitNumericType(ctx.numericType());
    } else if (ctx.BOOLEAN() != null) {
      return configureNode(new BooleanType(), ctx);
    } else if (ctx.STRING() != null) {
      return configureNode(new StringType(), ctx);
    } else if (ctx.BARRIER() != null) {
      return configureNode(new BarrierType(), ctx);
    }
    return configureNode(new TimerType(), ctx);
  }

  @Override
  public Primitive visitNumericType(ProcessJParser.NumericTypeContext ctx) {
    if (ctx.integralType() != null) {
      return visitIntegralType(ctx.integralType());
    }
    return visitFloatingPointType(ctx.floatingPointType());
  }

  @Override
  public Primitive visitIntegralType(ProcessJParser.IntegralTypeContext ctx) {
    if (ctx.BYTE() != null) {
      return configureNode(new ByteType(), ctx);
    } else if (ctx.SHORT() != null) {
      return configureNode(new ShortType(), ctx);
    } else if (ctx.INT() != null) {
      return configureNode(new IntegerType(), ctx);
    } else if (ctx.LONG() != null) {
      return configureNode(new LongType(), ctx);
    }
    return configureNode(new CharType(), ctx);
  }

  @Override
  public Primitive visitFloatingPointType(ProcessJParser.FloatingPointTypeContext ctx) {
    if (ctx.FLOAT() != null) {
      return configureNode(new FloatType(), ctx);
    }
    return configureNode(new DoubleType(), ctx);
  }

  @Override
  public Type visitReferenceType(ProcessJParser.ReferenceTypeContext ctx) {
    if (ctx.arrayType() != null) {
      return configureNode(visitArrayType(ctx.arrayType()), ctx);
    } else if (ctx.channelType() != null) {
      return configureNode((Type) visit(ctx.channelType()), ctx);
    }
    return configureNode((Type) visit(ctx.typeVariable()), ctx);
  }

  @Override
  public ArrayType visitArrayType(ProcessJParser.ArrayTypeContext ctx) {
    ArrayType array = visitDims(ctx.dims());
    if (ctx.primitiveType() != null) {
      Type type = visitPrimitiveType(ctx.primitiveType());
      array.setComponentType(type);
    } else if (ctx.channelType() != null) {
      Type type = (Type) visit(ctx.channelType());
      array.setComponentType(type);
    } else if (ctx.typeVariable() != null) {
      Type type = (Type) visit(ctx.typeVariable());
      array.setComponentType(type);
    }
    return getParentArray(array);
  }

  // we build an array-type in reverse order so that in the body of
  // the caller we can set its component-type; e.g.:
  //
  //   ArrayType(ArrayType(ArrayType(<component-type>)))
  //
  // where component-type can be an atomic or constructed type
  @Override
  public ArrayType visitDims(ProcessJParser.DimsContext ctx) {
    ArrayType outerType = configureNode(new ArrayType(), ctx.LBRACK(0));
    for (int i = 1; i < ctx.LBRACK().size(); ++i) {
      ArrayType innerType = configureNode(new ArrayType(), ctx.LBRACK(i));
      outerType.setComponentType(innerType);
      outerType = innerType;
    }
    return outerType;
  }

  @Override
  public ChannelType visitChannelSharedReadType(ProcessJParser.ChannelSharedReadTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_READ);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedWriteType(ProcessJParser.ChannelSharedWriteTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_WRITE);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedType(ProcessJParser.ChannelSharedTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelType_(ProcessJParser.ChannelType_Context ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.NON_SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotRead(ProcessJParser.ChannelDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotWrite(ProcessJParser.ChannelDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public Object visitChannelSharedDotRead(ProcessJParser.ChannelSharedDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public Object visitChannelSharedDotWrite(ProcessJParser.ChannelSharedDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public TypeVariable visitTypeVariableIdentifier(ProcessJParser.TypeVariableIdentifierContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    return configureNode(new TypeVariable(name), ctx);
  }

  @Override
  public Sequence<Parameter> visitFormarlParameterList(ProcessJParser.FormarlParameterListContext ctx) {
    Sequence<Parameter> parameters = Sequence.sequenceList();
    if (ctx.formalParameters() != null) {
      parameters.addAll(visitFormalParameters(ctx.formalParameters()));
    }
    if (ctx.lastFormalDeclaration() != null) {
      parameters.add(visitLastFormalDeclaration(ctx.lastFormalDeclaration()));
    }
    return parameters;
  }

  @Override
  public Sequence<Parameter> visitFormalParameters(ProcessJParser.FormalParametersContext ctx) {
    Sequence<Parameter> params = Sequence.sequenceList();
    ctx.formalParameter().forEach(p -> params.add(visitFormalParameter(p)));
    return params;
  }

  @Override
  public Parameter visitFormalParameter(ProcessJParser.FormalParameterContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.variableModifier().size(); ++i) {
      Object obj = visitVariableModifier(ctx.variableModifier(i));
      if (obj instanceof Integer) {
        modifiers += (Integer) obj;
      }
    }
    Parameter parameter = new Parameter();
    parameter.setModifiers(modifiers);
    ASTType type = visitType_(ctx.type_());
    Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
    if (tuple.isTuple1()) {
      Tuple1<String> t1 = tuple.asTuple1();
      parameter.setName(t1.getV1());
      parameter.setASTType(type);
      configureNode(parameter, ctx.variableDeclaratorIdentifier());
    } else {
      Tuple2<String, ArrayType> t2 = tuple.asTuple2();
      ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
      arrayNode.getTSType().setTSType(type.getTSType());
      parameter.setASTType(arrayNode);
      parameter.setName(t2.getV1());
      configureNode(parameter, ctx);
    }
    return parameter;
  }

  @Override
  public Parameter visitLastFormalDeclaration(ProcessJParser.LastFormalDeclarationContext ctx) {
    if (ctx.type_() != null) {
      Parameter parameter = new Parameter();
      ASTType type = visitType_(ctx.type_());
      Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
      if (tuple.isTuple1()) {
        Tuple1<String> t1 = tuple.asTuple1();
        parameter.setName(t1.getV1());
        parameter.setASTType(type);
        configureNode(parameter, ctx.variableDeclaratorIdentifier());
      } else {
        Tuple2<String, ArrayType> t2 = tuple.asTuple2();
        ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
        arrayNode.getTSType().setTSType(type.getTSType());
        parameter.setASTType(arrayNode);
        parameter.setName(t2.getV1());
        configureNode(parameter, ctx);
      }
    }
    return visitFormalParameter(ctx.formalParameter());
  }

  @Override
  public Tuple<?> visitVariableDeclaratorIdentifier(ProcessJParser.VariableDeclaratorIdentifierContext ctx) {
    String name = ctx.Identifier().getText();
    if (ctx.dims() != null) {
      ArrayType type = visitDims(ctx.dims());
      return Tuple2.tuple(name, type);
    }
    return Tuple1.tuple(name);
  }

  @Override
  public Object visitVariableModifier(ProcessJParser.VariableModifierContext ctx) {
    // TODO: annotations?
    if (ctx.CONST() != null) {
      return Opcodes.ACC_FINAL;
    }
    return null;
  }

  @Override
  public RecordDecl visitRecordTypeDeclaration(ProcessJParser.RecordTypeDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    final String identifier = ctx.Identifier().getText();
    Sequence<FieldDeclaration> fields = visitRecordBody(ctx.recordBody());
    // TODO: extends
    RecordDecl recordDecl = new RecordDecl();
    recordDecl.setModifiers(modifiers);
    recordDecl.setName(identifier);
    recordDecl.setDeclaredFields(fields);
    return configureNode(recordDecl, ctx);
  }

  @Override
  public Object visitExtends(ProcessJParser.ExtendsContext ctx) {
    return null;
  }

  @Override
  public Sequence<FieldDeclaration> visitRecordBody(ProcessJParser.RecordBodyContext ctx) {
    Sequence<FieldDeclaration> fields = Sequence.sequenceList();
    ctx.recordMemberDeclaration().forEach(r -> fields.addAll(visitRecordMemberDeclaration(r)));
    return fields;
  }

  @Override
  public Sequence<FieldDeclaration> visitRecordMemberDeclaration(ProcessJParser.RecordMemberDeclarationContext ctx) {
    Sequence<FieldDeclaration> fields = Sequence.sequenceList();
    ASTType type = visitType_(ctx.type_());
    List<Tuple<?>> variables = visitRecordMemberDeclarators(ctx.recordMemberDeclarators());
    for (Tuple<?> v : variables) {
      VariableDecl variableDecl = new VariableDecl();
      if (v.isTuple1()) {
        Tuple1<String> t1 = v.asTuple1();
        variableDecl.setName(t1.getV1());
        variableDecl.setASTType(type);
        configureNode(variableDecl, ctx.recordMemberDeclarators());
      } else {
        Tuple2<String, ArrayType> t2 = v.asTuple2();
        ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
        arrayNode.getTSType().setTSType(type.getTSType());
        variableDecl.setASTType(arrayNode);
        variableDecl.setName(t2.getV1());
        configureNode(variableDecl, ctx);
      }
      fields.add(configureNode(new FieldDeclaration(variableDecl), ctx));
    }
    return fields;
  }

  @Override
  public List<Tuple<?>> visitRecordMemberDeclarators(ProcessJParser.RecordMemberDeclaratorsContext ctx) {
    List<Tuple<?>> variables = new ArrayList<>();
    ctx.recordMemberDeclarator().forEach(r -> variables.add(visitRecordMemberDeclarator(r)));
    return variables;
  }

  @Override
  public Tuple<?> visitRecordMemberDeclarator(ProcessJParser.RecordMemberDeclaratorContext ctx) {
    return visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
  }

  @Override
  public ProtocolDecl visitProtocolTypeDeclaration(ProcessJParser.ProtocolTypeDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    final String identifier = ctx.Identifier().getText();
    ProtocolDecl protocolDecl = new ProtocolDecl();
    protocolDecl.setModifiers(modifiers);
    protocolDecl.setName(identifier);
    // TODO: extends?
    if (ctx.protocolBody() != null) {
      protocolDecl.setDeclaredTags(visitProtocolBody(ctx.protocolBody()));
    }
    return configureNode(protocolDecl, ctx);
  }

  @Override
  public Sequence<ProtocolCaseDecl> visitProtocolBody(ProcessJParser.ProtocolBodyContext ctx) {
    Sequence<ProtocolCaseDecl> cases = Sequence.sequenceList();
    ctx.protocolCase().forEach(c -> cases.add(visitProtocolCase(c)));
    return cases;
  }

  @Override
  public ProtocolCaseDecl visitProtocolCase(ProcessJParser.ProtocolCaseContext ctx) {
    final String identifier = ctx.Identifier().getText();
    Sequence<FieldDeclaration> fields = visitRecordBody(ctx.recordBody());
    ProtocolCaseDecl caseDecl = new ProtocolCaseDecl();
    caseDecl.setName(identifier);
    caseDecl.setDeclaredFields(fields);
    return configureNode(caseDecl, ctx);
  }

  @Override
  public ConstantDecl visitConstantDeclaration(ProcessJParser.ConstantDeclarationContext ctx) {
    return null;
  }

  @Override
  public Object visitConstantDeclarators(ProcessJParser.ConstantDeclaratorsContext ctx) {
    return null;
  }

  @Override
  public Object visitConstantDeclarator(ProcessJParser.ConstantDeclaratorContext ctx) {
    return null;
  }

  // Statements

  @Override
  public Object visitBlockAsStatement(ProcessJParser.BlockAsStatementContext ctx) {
    return null;
  }

  @Override
  public BlockStmt visitBlock(ProcessJParser.BlockContext ctx) {
    Sequence<Statement> stmt = Sequence.sequenceList();
    if (ctx.blockStatement() != null) {
      ctx.blockStatement().forEach(s -> stmt.addAll(visitBlockStatement(s)));
    }
    return configureNode(new BlockStmt(stmt), ctx);
  }

  @Override
  public Sequence<Statement> visitBlockStatement(ProcessJParser.BlockStatementContext ctx) {
    if (ctx.localVariableDeclarationStatement() != null) {
      return visitLocalVariableDeclarationStatement(ctx.localVariableDeclarationStatement());
    }
    Statement stat = (Statement) visit(ctx.statement());
    return null;
  }

  @Override
  public Sequence<Statement> visitLocalVariableDeclarationStatement(ProcessJParser.LocalVariableDeclarationStatementContext ctx) {
    Sequence<Statement> stmts = Sequence.sequenceList();
    Sequence<VariableDecl> variables = visitLocalVariableDeclaration(ctx.localVariableDeclaration());
    variables.forEach(v -> {
      DeclarationExpr declarationExpr = configureNode(new DeclarationExpr(v), v);
      ExpressionStmt expressionStmt = new ExpressionStmt(declarationExpr);
      stmts.add(configureNode(expressionStmt, v));
    });
    return null;
  }

  @Override
  public Sequence<VariableDecl> visitLocalVariableDeclaration(ProcessJParser.LocalVariableDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.variableModifier().size(); ++i) {
      Object obj = visitVariableModifier(ctx.variableModifier(i));
      if (obj instanceof Integer) {
        modifiers += (Integer) obj;
      }
    }
    ASTType type = visitType_(ctx.type_());
    Sequence<VariableDecl> variables = visitVariableDeclaratorList(ctx.variableDeclaratorList());
    for (VariableDecl v : variables) {
      if (v.getASTType() != null && v.getASTType().isArrayNode()) {
        v.getASTType().setASTType(type);
      } else {
        v.setASTType(type);
      }
      v.setModifiers(modifiers);
    }
    return variables;
  }

  @Override
  public Sequence<VariableDecl> visitVariableDeclaratorList(ProcessJParser.VariableDeclaratorListContext ctx) {
    Sequence<VariableDecl> variables = Sequence.sequenceList();
    ctx.variableDeclarator().forEach(v -> variables.add(visitVariableDeclarator(v)));
    return variables;
  }

  @Override
  public VariableDecl visitVariableDeclarator(ProcessJParser.VariableDeclaratorContext ctx) {
    VariableDecl variableDecl = new VariableDecl();
    Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
    if (tuple.isTuple1()) {
      Tuple1<String> t1 = tuple.asTuple1();
      variableDecl.setName(t1.getV1());
      configureNode(variableDecl, ctx.variableDeclaratorIdentifier());
    } else {
      Tuple2<String, ArrayType> t2 = tuple.asTuple2();
      ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
      variableDecl.setASTType(arrayNode);
      variableDecl.setName(t2.getV1());
      configureNode(variableDecl, ctx);
    }
    return configureNode(variableDecl, ctx);
  }

  @Override
  public IfStmt visitIfStatement(ProcessJParser.IfStatementContext ctx) {
    Expression<?> conditional = visitParExpression(ctx.parExpression());
    Statement thenPart = (Statement) visit(ctx.statement(0));
    Statement elsePart = null;
    if (ctx.ELSE() != null) {
      elsePart = (Statement) visit(ctx.statement(1));
    }
    BooleanExpr booleanExpr = configureNode(new BooleanExpr(conditional), conditional);
    IfStmt ifStmt = new IfStmt(booleanExpr, thenPart, elsePart);
    return configureNode(ifStmt, ctx);
  }

  @Override
  public Expression<?> visitParExpression(ProcessJParser.ParExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    return configureNode(expression, ctx);
  }

  @Override
  public Statement visitForStatement(ProcessJParser.ForStatementContext ctx) {
    Statement forStmt = visitForControl(ctx.forControl());
    Statement statement = (Statement) visit(ctx.statement());
    if (forStmt.isForStmt()) {
      forStmt.asForStmt().setLoopBlock(statement);
    } else {
      forStmt.asForEachStmt().setLoopBlock(statement);
    }
    return configureNode(forStmt, ctx);
  }

  @Override
  public Statement visitForControl(ProcessJParser.ForControlContext ctx) {
    if (ctx.enhancedForControl() != null) {
      // TODO: ??
    }
    ForStmt forStmt = new ForStmt();
    if (ctx.forInit() != null) {
      forStmt.setInitialization(visitForInit(ctx.forInit()));
    }
    if (ctx.expression() != null) {
      Expression<?> conditional = (Expression<?>) visit(ctx.expression());
      BooleanExpr booleanExpr = configureNode(new BooleanExpr(conditional), conditional);
      forStmt.setCondition(booleanExpr);
    }
    if (ctx.forUpdate != null) {
      forStmt.setUpdate(visitExpressionList(ctx.forUpdate));
    }
    return forStmt;
  }

  @Override
  public Sequence<Expression<?>> visitForInit(ProcessJParser.ForInitContext ctx) {
    if (ctx.localVariableDeclaration() != null) {
      Sequence<VariableDecl> variables = visitLocalVariableDeclaration(ctx.localVariableDeclaration());
      Sequence<Expression<?>> declarations = Sequence.sequenceList();
      variables.forEach(v -> declarations.add(configureNode(new DeclarationExpr(v), v)));
      return declarations;
    }
    return visitExpressionList(ctx.expressionList());
  }

  @Override
  public Sequence<Expression<?>> visitExpressionList(ProcessJParser.ExpressionListContext ctx) {
    Sequence<Expression<?>> lst = Sequence.sequenceList();
    ctx.expression().forEach(e -> lst.add((Expression<?>) visit(e)));
    return lst;
  }

  @Override
  public RegularAltStmt visitAltStatement(ProcessJParser.AltStatementContext ctx) {
    Sequence<AltCase> altCases = visitAltBody(ctx.altBody());
    RegularAltStmt altStmt = new RegularAltStmt();
    altStmt.setAltCases(altCases);
    altStmt.setFairAlt(ctx.PRI() != null);
    return configureNode(altStmt, ctx);
  }

  @Override
  public ReplicatedAltStmt visitAltForStatement(ProcessJParser.AltForStatementContext ctx) {
    ForStmt forStmt = visitForControl(ctx.forControl()).asForStmt();
    ReplicatedAltStmt replicatedAlt = new ReplicatedAltStmt();
    replicatedAlt.setInitialization(forStmt.getInitialization());
    replicatedAlt.setConditional(forStmt.getConditional());
    replicatedAlt.setUpdate(forStmt.getUpdate());
    replicatedAlt.setStatementLabels(forStmt.getStatementLabels().orElse(null));
    replicatedAlt.setAltCases(visitAltBody(ctx.altBody()));
    return configureNode(replicatedAlt, ctx);
  }

  @Override
  public Sequence<AltCase> visitAltBody(ProcessJParser.AltBodyContext ctx) {
    Sequence<AltCase> altCases = Sequence.sequenceList();
    ctx.altCase().forEach(ac -> altCases.add(visitAltCase(ac)));
    return altCases;
  }

  @Override
  public AltCase visitAltCase(ProcessJParser.AltCaseContext ctx) {
    if (ctx.parExpression() != null && ctx.ANDAND() != null) {
      Expression<?> expression = (Expression<?>) visit(ctx.parExpression());
      Guard guard = visitAltGuard(ctx.altGuard());
      Statement statement = (Statement) visit(ctx.statement());
      AltCase altCase = new AltCase(expression, guard, statement);
      return configureNode(altCase, ctx);
    }
    if (ctx.altGuard() != null) {
      Guard guard = visitAltGuard(ctx.altGuard());
      Statement statement = (Statement) visit(ctx.statement());
      AltCase altCase = new AltCase(guard, statement);
      return configureNode(altCase, ctx);
    }
    Statement statement = (Statement) visit(ctx.statement());
    AltCase altCase = new AltCase(statement);
    return configureNode(altCase, ctx);
  }

  @Override
  public Guard visitAltGuard(ProcessJParser.AltGuardContext ctx) {
    Guard guard = new Guard();
    if (ctx.SKIP_() != null) {
      guard.setSkip(true);
      return configureNode(guard, ctx);
    }
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    guard.setExpression(expression);
    return configureNode(guard, ctx);
  }

  @Override
  public Object visitParStatement(ProcessJParser.ParStatementContext ctx) {
    return null;
  }

  @Override
  public WhileStmt visitWhileStatement(ProcessJParser.WhileStatementContext ctx) {
    Expression<?> conditional = (Expression<?>) visit(ctx.parExpression());
    Statement statement = (Statement) visit(ctx.statement());
    BooleanExpr booleanExpr = configureNode(new BooleanExpr(conditional), conditional);
    WhileStmt whileStmt = new WhileStmt(booleanExpr, statement);
    return configureNode(whileStmt, ctx);
  }

  @Override
  public Object visitSwitchStatement(ProcessJParser.SwitchStatementContext ctx) {
    return null;
  }

  @Override
  public Object visitSwitchBlockStatementGroup(ProcessJParser.SwitchBlockStatementGroupContext ctx) {
    return null;
  }

  @Override
  public Object visitSwitchLabel(ProcessJParser.SwitchLabelContext ctx) {
    return null;
  }

  @Override
  public ReturnStmt visitReturnStatement(ProcessJParser.ReturnStatementContext ctx) {
    ReturnStmt returnStmt = new ReturnStmt();
    if (ctx.expression() != null) {
      returnStmt.setExpression((Expression<?>) visit(ctx.expression()));
    }
    return configureNode(returnStmt, ctx);
  }

  @Override
  public BreakStmt visitBreakStatement(ProcessJParser.BreakStatementContext ctx) {
    BreakStmt breakStmt = new BreakStmt();
    if (ctx.Identifier() != null) {
      breakStmt.setLabel(ctx.Identifier().getText());
    }
    return configureNode(breakStmt, ctx);
  }

  @Override
  public ContinueStmt visitContinueStatement(ProcessJParser.ContinueStatementContext ctx) {
    ContinueStmt continueStmt = new ContinueStmt();
    if (ctx.Identifier() != null) {
      continueStmt.setLabel(ctx.Identifier().getText());
    }
    return configureNode(continueStmt, ctx);
  }

  @Override
  public EmptyStmt visitEmptyStatement(ProcessJParser.EmptyStatementContext ctx) {
    return configureNode(new EmptyStmt(), ctx);
  }

  @Override
  public ExpressionStmt visitStatementExpression(ProcessJParser.StatementExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    ExpressionStmt expressionStmt = new ExpressionStmt(expression);
    return configureNode(expressionStmt, ctx);
  }

  @Override
  public Object visitLabelStatement(ProcessJParser.LabelStatementContext ctx) {
    // TODO: ??
    return null;
  }
}
