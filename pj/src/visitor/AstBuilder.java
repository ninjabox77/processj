package visitor;

import ast.*;
import ast.Package;
import ast.expr.*;
import ast.java.FieldDeclaration;
import ast.stmt.*;
import ast.toplevel.*;
import ast.types.*;
import misc.Tuple;
import misc.Tuple1;
import misc.Tuple2;
import org.jetbrains.annotations.NotNull;
import org.objectweb.asm.Opcodes;
import parser.ProcessJBaseVisitor;
import parser.ProcessJParser;
import typesystem.*;

import java.util.ArrayList;
import java.util.List;

import static misc.ConfigureAST.configureNode;


/**
 * Builds the AST from the parse tree generated by antlr4.
 *
 * @author Ben
 */
public class AstBuilder extends ProcessJBaseVisitor<Object> {

  private ArrayType getParentArray(ArrayType array) {
    while (!array.isOrphan()) {
      array = (ArrayType) array.getParentNode().get();
    }
    return array;
  }

  @Override
  public CompileUnit visitCompilationUnit(ProcessJParser.CompilationUnitContext ctx) {
    Package _package = null;
    if (ctx.packageDeclaration() != null) {
      _package = visitPackageDeclaration(ctx.packageDeclaration());
    }
    Sequence<Import> imports = Sequence.sequenceList();
    ctx.importDeclaration().forEach(i -> imports.add(visitImportDeclaration(i)));
    Sequence<TopLevelDeclaration<?>> typeDecls = Sequence.sequenceList();
    ctx.typeDeclaration().forEach(t -> {
      Object obj = visitTypeDeclaration(t);
      if (obj instanceof Sequence<?>) {
        Sequence<TopLevelDeclaration<?>> constantDecls = (Sequence<TopLevelDeclaration<?>>) obj;
        typeDecls.addAll(constantDecls);
      } else {
        typeDecls.add((TopLevelDeclaration<?>) obj);
      }
    });
    CompileUnit compileUnit = new CompileUnit(_package, imports, typeDecls);
    return configureNode(compileUnit, ctx);
  }

  @Override
  public Package visitPackageDeclaration(ProcessJParser.PackageDeclarationContext ctx) {
    Package _package = new Package(visitPackageName(ctx.packageName()));
    return configureNode(_package, ctx);
  }

  @Override
  public Name visitPackageName(ProcessJParser.PackageNameContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    if (ctx.packageName() != null) {
      name.setQualifier(visitPackageName(ctx.packageName()));
    }
    return name;
  }

  @Override
  public Import visitImportDeclaration(ProcessJParser.ImportDeclarationContext ctx) {
    if (ctx.singleTypeImportDeclaration() != null) {
      return visitSingleTypeImportDeclaration(ctx.singleTypeImportDeclaration());
    }
    if (ctx.singleTypeMultiImportDeclaration() != null) {
      return visitSingleTypeMultiImportDeclaration(ctx.singleTypeMultiImportDeclaration());
    }
    if (ctx.singleStaticMultiImportDeclaration() != null) {
      return visitSingleStaticImportDeclaration(ctx.singleStaticImportDeclaration());
    }
    return visitSingleStaticMultiImportDeclaration(ctx.singleStaticMultiImportDeclaration());
  }

  @Override
  public Name visitTypeName(ProcessJParser.TypeNameContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    if (ctx.typeName() != null) {
      name.setQualifier(visitTypeName(ctx.typeName()));
    }
    return name;
  }

  @Override
  public Import visitSingleTypeImportDeclaration(ProcessJParser.SingleTypeImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    if (ctx.DCOLON() != null) {
      _import.setFieldName(ctx.Identifier().getText());
    }
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitSingleTypeMultiImportDeclaration(ProcessJParser.SingleTypeMultiImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    _import.setStar(true);
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitSingleStaticImportDeclaration(ProcessJParser.SingleStaticImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    if (ctx.DOT() != null) {
      _import.setFieldName(ctx.Identifier().getText());
    }
    _import.setJavaImport(true);
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitSingleStaticMultiImportDeclaration(ProcessJParser.SingleStaticMultiImportDeclarationContext ctx) {
    Import _import = new Import();
    if (ctx.typeName() != null) {
      _import.setName(visitTypeName(ctx.typeName()));
    }
    _import.setStar(true);
    _import.setJavaImport(true);
    return configureNode(_import, ctx);
  }

  @Override
  public Object visitTypeDeclaration(ProcessJParser.TypeDeclarationContext ctx) {
    if (ctx.procedureTypeDeclaration() != null) {
      return visitProcedureTypeDeclaration(ctx.procedureTypeDeclaration());
    }
    if (ctx.recordTypeDeclaration() != null) {
      return visitRecordTypeDeclaration(ctx.recordTypeDeclaration());
    }
    if (ctx.protocolTypeDeclaration() != null) {
      return visitProtocolTypeDeclaration(ctx.protocolTypeDeclaration());
    }
    if (ctx.constantDeclaration() != null) {
      return visitConstantDeclaration(ctx.constantDeclaration());
    }
    return null;
  }

  @Override
  public ProcedureTopLevel visitProcedureTypeDeclaration(ProcessJParser.ProcedureTypeDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    NodeType type = createNodeType(visitType_(ctx.type_()));
    final String identifier = ctx.Identifier().getText();
    Sequence<Parameter> parameters = Sequence.sequenceList();
    if (ctx.formarlParameterList() != null) {
      parameters.addAll(visitFormarlParameterList(ctx.formarlParameterList()));
    }
    ProcedureTopLevel procedure = new ProcedureTopLevel();
    procedure.setModifiers(modifiers);
    procedure.setNodeType(type);
    procedure.setName(identifier);
    procedure.setParameters(parameters);
    if (ctx.body() != null) {
      procedure.setBody(visitBody(ctx.body()));
    }
    return configureNode(procedure, ctx);
  }

  @Override
  public BlockStatement visitBody(ProcessJParser.BodyContext ctx) {
    return visitBlock(ctx.block());
  }

  @Override
  public Integer visitModifier(ProcessJParser.ModifierContext ctx) {
    if (ctx.PRIVATE() != null) {
      return Opcodes.ACC_PRIVATE;
    }
    if (ctx.PROTECTED() != null) {
      return Opcodes.ACC_PROTECTED;
    }
    if (ctx.CONST() != null) {
      return Opcodes.ACC_FINAL;
    }
    if (ctx.NATIVE() != null) {
      return Opcodes.ACC_NATIVE;
    }
    return Opcodes.ACC_PRIVATE;
  }

  private NodeType createNodeType(Type type) {
    if (type.isPrimitiveType()) {
      Primitive t = type.asPrimitiveType();
      if (t.isBarrierType()) {
        return configureNode(new BarrierNode(t.asBarrierType()), t);
      }
      if (t.isTimerType()) {
        return configureNode(new TimerNode(t.asTimerType()), t);
      }
      return configureNode(new PrimitiveNode(t), t);
    } else if (type.isConstructedType()) {
      Constructed t = type.asConstructedType();
      if (t.isArrayType()) {
        return configureNode(new ArrayNode(t.asArrayType()), t);
      }
      if (t.isChannelType()) {
        return configureNode(new ChannelNode(t.asChannelType()), t);
      }
      if (t.isChannelEndType()) {
        return configureNode(new ChannelEndNode(t.asChannelEndType()), t);
      }
      if (t.isNamedType()) {
        return configureNode(new ConstructedNode(t.asNamedType()), t);
      }
      return configureNode(new ConstructedNode(t), t);
    }
    return configureNode(new VoidNode(type), type);
  }

  @Override
  public Type visitType_(ProcessJParser.Type_Context ctx) {
    if (ctx.primitiveType() != null) {
      return visitPrimitiveType(ctx.primitiveType());
    } else if (ctx.referenceType() != null) {
      return visitReferenceType(ctx.referenceType());
    } else if (ctx.classType() != null) {
      // TODO: this is for when a Java class is used
    }
    return configureNode(new VoidType(), ctx);
  }


  @Override
  public Primitive visitPrimitiveType(ProcessJParser.PrimitiveTypeContext ctx) {
    if (ctx.numericType() != null) {
      return visitNumericType(ctx.numericType());
    } else if (ctx.BOOLEAN() != null) {
      return configureNode(new BooleanType(), ctx);
    } else if (ctx.STRING() != null) {
      return configureNode(new StringType(), ctx);
    } else if (ctx.BARRIER() != null) {
      return configureNode(new BarrierType(), ctx);
    }
    return configureNode(new TimerType(), ctx);
  }

  @Override
  public Primitive visitNumericType(ProcessJParser.NumericTypeContext ctx) {
    if (ctx.integralType() != null) {
      return visitIntegralType(ctx.integralType());
    }
    return visitFloatingPointType(ctx.floatingPointType());
  }

  @Override
  public Primitive visitIntegralType(ProcessJParser.IntegralTypeContext ctx) {
    if (ctx.BYTE() != null) {
      return configureNode(new ByteType(), ctx);
    } else if (ctx.SHORT() != null) {
      return configureNode(new ShortType(), ctx);
    } else if (ctx.INT() != null) {
      return configureNode(new IntegerType(), ctx);
    } else if (ctx.LONG() != null) {
      return configureNode(new LongType(), ctx);
    }
    return configureNode(new CharType(), ctx);
  }

  @Override
  public Primitive visitFloatingPointType(ProcessJParser.FloatingPointTypeContext ctx) {
    if (ctx.FLOAT() != null) {
      return configureNode(new FloatType(), ctx);
    }
    return configureNode(new DoubleType(), ctx);
  }

  @Override
  public Type visitReferenceType(ProcessJParser.ReferenceTypeContext ctx) {
    if (ctx.arrayType() != null) {
      return configureNode(visitArrayType(ctx.arrayType()), ctx);
    } else if (ctx.channelType() != null) {
      return configureNode((Type) visit(ctx.channelType()), ctx);
    }
    return configureNode(visitTypeVariable(ctx.typeVariable()), ctx);
  }

  @Override
  public ArrayType visitArrayType(ProcessJParser.ArrayTypeContext ctx) {
    ArrayType array = visitDims(ctx.dims());
    if (ctx.primitiveType() != null) {
      Type type = visitPrimitiveType(ctx.primitiveType());
      array.setComponentType(type);
    } else if (ctx.channelType() != null) {
      Type type = (Type) visit(ctx.channelType());
      array.setComponentType(type);
    } else if (ctx.typeVariable() != null) {
      NamedType type = visitTypeVariable(ctx.typeVariable());
      array.setComponentType(type);
    }
    return getParentArray(array);
  }

  // We build an array-type in reverse order so that in the body of
  // the caller we can set its component-type; e.g.:
  //
  //   ArrayType(ArrayType(ArrayType(<component-type>)))
  //
  // where component-type can be an atomic or constructed type
  @Override
  public ArrayType visitDims(ProcessJParser.DimsContext ctx) {
    ArrayType outerType = configureNode(new ArrayType(), ctx.LBRACK(0));
    for (int i = 1; i < ctx.LBRACK().size(); ++i) {
      ArrayType innerType = configureNode(new ArrayType(), ctx.LBRACK(i));
      outerType.setComponentType(innerType);
      outerType = innerType;
    }
    return outerType;
  }

  @Override
  public ChannelType visitChannelSharedReadType(ProcessJParser.ChannelSharedReadTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_READ);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedWriteType(ProcessJParser.ChannelSharedWriteTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_WRITE);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedType(ProcessJParser.ChannelSharedTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelType_(ProcessJParser.ChannelType_Context ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.NON_SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotRead(ProcessJParser.ChannelDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotWrite(ProcessJParser.ChannelDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelSharedDotRead(ProcessJParser.ChannelSharedDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelSharedDotWrite(ProcessJParser.ChannelSharedDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public NamedType visitTypeVariable(ProcessJParser.TypeVariableContext ctx) {
    if (ctx.typeName() != null) {
      Name qualified = visitTypeName(ctx.typeName());
      Name name = configureNode(new Name(qualified, ctx.Identifier().getText()), qualified);
      return configureNode(new NamedType(name), ctx);
    }
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    return configureNode(new NamedType(name), ctx);
  }

  @Override
  public Sequence<Parameter> visitFormarlParameterList(ProcessJParser.FormarlParameterListContext ctx) {
    Sequence<Parameter> parameters = Sequence.sequenceList();
    if (ctx.formalParameters() != null) {
      parameters.addAll(visitFormalParameters(ctx.formalParameters()));
    }
    if (ctx.lastFormalDeclaration() != null) {
      parameters.add(visitLastFormalDeclaration(ctx.lastFormalDeclaration()));
    }
    return parameters;
  }

  @Override
  public Sequence<Parameter> visitFormalParameters(ProcessJParser.FormalParametersContext ctx) {
    Sequence<Parameter> params = Sequence.sequenceList();
    ctx.formalParameter().forEach(p -> params.add(visitFormalParameter(p)));
    return params;
  }

  @Override
  public Parameter visitFormalParameter(ProcessJParser.FormalParameterContext ctx) {
    int modifiers = 0;
    if (ctx.variableModifier() != null) {
      modifiers = visitVariableModifier(ctx.variableModifier());
    }
    Parameter parameter = new Parameter();
    parameter.setModifiers(modifiers);
    NodeType type = createNodeType(visitType_(ctx.type_()));
    Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
    if (tuple.isTuple1()) {
      Tuple1<String> t1 = tuple.asTuple1();
      parameter.setName(t1.getV1());
      parameter.setNodeType(type);
      configureNode(parameter, ctx.variableDeclaratorIdentifier());
    } else {
      Tuple2<String, ArrayType> t2 = tuple.asTuple2();
      ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
      arrayNode.setBracketPosition(ArrayNode.BracketPosition.NAME);
      setBaseType(type, arrayNode);
      parameter.setNodeType(arrayNode);
      parameter.setName(t2.getV1());
      configureNode(parameter, ctx);
    }
    return parameter;
  }

  public ArrayType getBaseType(Type type) {
    while (type instanceof ArrayType) {
      Type ct = ((ArrayType) type).getComponentType();
      if (!(ct instanceof ArrayType)) {
        break;
      }
      type = ct;
    }
    return (ArrayType) type;
  }

  public void setBaseType(NodeType type, ArrayNode arrayType) {
    ArrayType t2 = arrayType.getTSType();
    if (type.isArrayNode()) {
      ArrayType t1 = type.getTSType().asConstructedType().asArrayType();
      t1 = getBaseType(t1);
      t2 = getBaseType(t2);
      t2.setComponentType(t1.getComponentType());
      t1.setComponentType(arrayType.getTSType());
      arrayType.setTSType(type.getTSType());
    } else {
      t2 = getBaseType(t2);
      t2.setComponentType(type.getTSType());
    }
  }

  @Override
  public Parameter visitLastFormalDeclaration(ProcessJParser.LastFormalDeclarationContext ctx) {
    if (ctx.type_() != null) {
      Parameter parameter = new Parameter();
      NodeType type = createNodeType(visitType_(ctx.type_()));
      Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
      if (tuple.isTuple1()) {
        Tuple1<String> t1 = tuple.asTuple1();
        ArrayType arrayType = configureNode(new ArrayType(type.getTSType()), type);
        ArrayNode arrayNode = configureNode(new ArrayNode(arrayType), arrayType);
        parameter.setName(t1.getV1());
        parameter.setNodeType(arrayNode);
        configureNode(parameter, ctx.variableDeclaratorIdentifier());
      } else {
        Tuple2<String, ArrayType> t2 = tuple.asTuple2();
        ArrayType arrayType = configureNode(new ArrayType(t2.getV2()), t2.getV2());
        ArrayNode arrayNode = configureNode(new ArrayNode(arrayType), arrayType);
        setBaseType(type, arrayNode);
        arrayNode.setBracketPosition(ArrayNode.BracketPosition.NAME);
        parameter.setNodeType(configureNode(arrayNode, arrayNode));
        parameter.setName(t2.getV1());
        configureNode(parameter, ctx);
      }
      parameter.setVarargs(true);
      return parameter;
    }
    return visitFormalParameter(ctx.formalParameter());
  }

  @Override
  public Tuple<?> visitVariableDeclaratorIdentifier(ProcessJParser.VariableDeclaratorIdentifierContext ctx) {
    String name = ctx.Identifier().getText();
    if (ctx.dims() != null) {
      ArrayType type = visitDims(ctx.dims());
      return Tuple2.tuple(name, getParentArray(type));
    }
    return Tuple1.tuple(name);
  }

  @Override
  public Integer visitVariableModifier(ProcessJParser.VariableModifierContext ctx) {
    return Opcodes.ACC_FINAL;
  }

  @Override
  public RecordDeclaration visitRecordTypeDeclaration(ProcessJParser.RecordTypeDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    final String identifier = ctx.Identifier().getText();
    Sequence<FieldDeclaration> fields = visitRecordBody(ctx.recordBody());
    RecordDeclaration recordDecl = new RecordDeclaration();
    recordDecl.setModifiers(modifiers);
    recordDecl.setName(identifier);
    recordDecl.setDeclaredFields(fields);
    if (ctx.extends_() != null) {
      Sequence<NamedType> types = visitExtends(ctx.extends_());
      Sequence<ConstructedNode> implNames = Sequence.sequenceList();
      types.forEach(t -> implNames.add(configureNode(new ConstructedNode(t), t)));
      recordDecl.setImplementedNames(implNames);
    }
    return configureNode(recordDecl, ctx);
  }

  @Override
  public Sequence<NamedType> visitExtends(ProcessJParser.ExtendsContext ctx) {
    Sequence<NamedType> types = Sequence.sequenceList();
    ctx.typeVariable().forEach(t -> types.add(visitTypeVariable(t)));
    return types;
  }

  @Override
  public Sequence<FieldDeclaration> visitRecordBody(ProcessJParser.RecordBodyContext ctx) {
    Sequence<FieldDeclaration> fields = Sequence.sequenceList();
    ctx.recordMemberDeclaration().forEach(r -> fields.addAll(visitRecordMemberDeclaration(r)));
    return fields;
  }

  @Override
  public Sequence<FieldDeclaration> visitRecordMemberDeclaration(ProcessJParser.RecordMemberDeclarationContext ctx) {
    Sequence<FieldDeclaration> fields = Sequence.sequenceList();
    NodeType type = createNodeType(visitType_(ctx.type_()));
    List<Tuple<?>> variables = visitRecordMemberDeclarators(ctx.recordMemberDeclarators());
    for (Tuple<?> v : variables) {
      VariableDeclarator variableDecl = new VariableDeclarator();
      if (v.isTuple1()) {
        Tuple1<String> t1 = v.asTuple1();
        variableDecl.setName(t1.getV1());
        variableDecl.setNodeType(type);
        configureNode(variableDecl, ctx.recordMemberDeclarators());
      } else {
        Tuple2<String, ArrayType> t2 = v.asTuple2();
        ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
        arrayNode.setBracketPosition(ArrayNode.BracketPosition.NAME);
        arrayNode.getTSType().setComponentType(type.getTSType());
        variableDecl.setNodeType(arrayNode);
        variableDecl.setName(t2.getV1());
        configureNode(variableDecl, ctx);
      }
      fields.add(configureNode(new FieldDeclaration(variableDecl), ctx));
    }
    return fields;
  }

  @Override
  public List<Tuple<?>> visitRecordMemberDeclarators(ProcessJParser.RecordMemberDeclaratorsContext ctx) {
    List<Tuple<?>> variables = new ArrayList<>();
    ctx.recordMemberDeclarator().forEach(r -> variables.add(visitRecordMemberDeclarator(r)));
    return variables;
  }

  @Override
  public Tuple<?> visitRecordMemberDeclarator(ProcessJParser.RecordMemberDeclaratorContext ctx) {
    return visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
  }

  @Override
  public ProtocolDeclaration visitProtocolTypeDeclaration(ProcessJParser.ProtocolTypeDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    final String identifier = ctx.Identifier().getText();
    ProtocolDeclaration protocolDecl = new ProtocolDeclaration();
    protocolDecl.setModifiers(modifiers);
    protocolDecl.setName(identifier);
    if (ctx.extends_() != null) {
      Sequence<NamedType> types = visitExtends(ctx.extends_());
      Sequence<ConstructedNode> implNames = Sequence.sequenceList();
      types.forEach(t -> implNames.add(configureNode(new ConstructedNode(t), t)));
      protocolDecl.setImplementedNames(implNames);
    }
    if (ctx.protocolBody() != null) {
      protocolDecl.setDeclaredTags(visitProtocolBody(ctx.protocolBody()));
    }
    return configureNode(protocolDecl, ctx);
  }

  @Override
  public Sequence<ProtocolCaseDeclaration> visitProtocolBody(ProcessJParser.ProtocolBodyContext ctx) {
    Sequence<ProtocolCaseDeclaration> cases = Sequence.sequenceList();
    ctx.protocolCase().forEach(c -> cases.add(visitProtocolCase(c)));
    return cases;
  }

  @Override
  public ProtocolCaseDeclaration visitProtocolCase(ProcessJParser.ProtocolCaseContext ctx) {
    final String identifier = ctx.Identifier().getText();
    Sequence<FieldDeclaration> fields = visitRecordBody(ctx.recordBody());
    ProtocolCaseDeclaration caseDecl = new ProtocolCaseDeclaration();
    caseDecl.setName(identifier);
    caseDecl.setDeclaredFields(fields);
    return configureNode(caseDecl, ctx);
  }

  @Override
  public Sequence<ConstantDeclaration> visitConstantDeclaration(ProcessJParser.ConstantDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    NodeType type = createNodeType(visitType_(ctx.type_()));
    Sequence<ConstantDeclaration> constantDecls = visitConstantDeclarators(ctx.constantDeclarators());
    for (ConstantDeclaration constantDecl : constantDecls) {
      if (constantDecl.getNodeType() != null) {
        ArrayNode arrayNode = constantDecl.getNodeType().asArrayNode();
        arrayNode.getTSType().setComponentType(type.getTSType());
      } else {
        constantDecl.setNodeType(type);
      }
      constantDecl.setModifiers(modifiers);
    }
    return constantDecls;
  }

  @Override
  public Sequence<ConstantDeclaration> visitConstantDeclarators(ProcessJParser.ConstantDeclaratorsContext ctx) {
    Sequence<ConstantDeclaration> constantDecls = Sequence.sequenceList();
    ctx.constantDeclarator().forEach(c -> constantDecls.add(visitConstantDeclarator(c)));
    return constantDecls;
  }

  @Override
  public ConstantDeclaration visitConstantDeclarator(ProcessJParser.ConstantDeclaratorContext ctx) {
    ConstantDeclaration constantDecl = new ConstantDeclaration();
    Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
    if (tuple.isTuple1()) {
      Tuple1<String> t1 = tuple.asTuple1();
      constantDecl.setName(t1.getV1());
      configureNode(constantDecl, ctx.variableDeclaratorIdentifier());
    } else {
      Tuple2<String, ArrayType> t2 = tuple.asTuple2();
      ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
      constantDecl.setNodeType(arrayNode);
      constantDecl.setName(t2.getV1());
      configureNode(constantDecl, ctx);
    }
    if (ctx.EQ() != null) {
      Expression<?> value = visitVariableInitializer(ctx.variableInitializer());
      constantDecl.setRightExpression(value);
    }
    return configureNode(constantDecl, ctx);
  }

  @Override
  public BlockStatement visitBlockAsStatement(ProcessJParser.BlockAsStatementContext ctx) {
    return visitBlock(ctx.block());
  }

  @Override
  public BlockStatement visitBlock(ProcessJParser.BlockContext ctx) {
    Sequence<Statement> stmt = Sequence.sequenceList();
    if (ctx.blockStatement() != null) {
      ctx.blockStatement().forEach(s -> stmt.addAll(visitBlockStatement(s)));
    }
    return configureNode(new BlockStatement(stmt), ctx);
  }

  @Override
  public Sequence<Statement> visitBlockStatement(ProcessJParser.BlockStatementContext ctx) {
    if (ctx.localVariableDeclarationStatement() != null) {
      return visitLocalVariableDeclarationStatement(ctx.localVariableDeclarationStatement());
    }
    Sequence<Statement> statements = Sequence.sequenceList();
    Object obj = visit(ctx.statement());
    if (obj instanceof Statement) {
      statements.add((Statement) obj);
    } else if (obj instanceof Sequence<?>) {
      statements.addAll((Sequence<? extends Statement>) obj);
    }
    return statements;
  }

  @Override
  public Sequence<Statement> visitLocalVariableDeclarationStatement(ProcessJParser.LocalVariableDeclarationStatementContext ctx) {
    Sequence<Statement> stmts = Sequence.sequenceList();
    Sequence<VariableDeclarator> variables = visitLocalVariableDeclaration(ctx.localVariableDeclaration());
    variables.forEach(v -> {
      DeclarationExpression declarationExpr = configureNode(new DeclarationExpression(v), v);
      ExpressionStatement expressionStmt = new ExpressionStatement(declarationExpr);
      stmts.add(configureNode(expressionStmt, v));
    });
    return stmts;
  }

  @Override
  public Sequence<VariableDeclarator> visitLocalVariableDeclaration(ProcessJParser.LocalVariableDeclarationContext ctx) {
    int modifiers = 0;
    if (ctx.variableModifier() != null) {
      modifiers = visitVariableModifier(ctx.variableModifier());
    }
    NodeType type = createNodeType(visitType_(ctx.type_()));
    Sequence<VariableDeclarator> variables = visitVariableDeclaratorList(ctx.variableDeclaratorList());
    for (VariableDeclarator v : variables) {
      if (v.getNodeType() != null) {
        ArrayNode arrayNode = v.getNodeType().asArrayNode();
        setBaseType(type, arrayNode);
      } else {
        v.setNodeType(type);
      }
      v.setModifiers(modifiers);
    }
    return variables;
  }

  @Override
  public Sequence<VariableDeclarator> visitVariableDeclaratorList(ProcessJParser.VariableDeclaratorListContext ctx) {
    Sequence<VariableDeclarator> variables = Sequence.sequenceList();
    ctx.variableDeclarator().forEach(v -> variables.add(visitVariableDeclarator(v)));
    return variables;
  }

  @Override
  public VariableDeclarator visitVariableDeclarator(ProcessJParser.VariableDeclaratorContext ctx) {
    VariableDeclarator variableDecl = new VariableDeclarator();
    Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
    if (tuple.isTuple1()) {
      Tuple1<String> t1 = tuple.asTuple1();
      variableDecl.setName(t1.getV1());
      configureNode(variableDecl, ctx.variableDeclaratorIdentifier());
    } else {
      Tuple2<String, ArrayType> t2 = tuple.asTuple2();
      ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
      variableDecl.setNodeType(arrayNode);
      variableDecl.setName(t2.getV1());
      configureNode(variableDecl, ctx);
    }
    if (ctx.EQ() != null) {
      Expression<?> initializer = visitVariableInitializer(ctx.variableInitializer());
      variableDecl.setRightExpression(initializer);
    }
    return configureNode(variableDecl, ctx);
  }

  @Override
  public IfStatement visitIfStatement(ProcessJParser.IfStatementContext ctx) {
    Expression<?> conditional = visitParExpression(ctx.parExpression());
    Statement thenPart = (Statement) visit(ctx.statement(0));
    Statement elsePart = null;
    if (ctx.ELSE() != null) {
      elsePart = (Statement) visit(ctx.statement(1));
    }
    BooleanExpression booleanExpr = configureNode(new BooleanExpression(conditional), conditional);
    IfStatement ifStmt = new IfStatement(booleanExpr, thenPart, elsePart);
    return configureNode(ifStmt, ctx);
  }

  @Override
  public Expression<?> visitParExpression(ProcessJParser.ParExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    return configureNode(expression, ctx);
  }

  @Override
  public Statement visitForStatement(ProcessJParser.ForStatementContext ctx) {
    Statement forStmt = visitForControl(ctx.forControl());
    Statement statement = (Statement) visit(ctx.statement());
    if (forStmt.isForStatement()) {
      forStmt.asForStatement().setLoopBlock(statement);
    } else {
      forStmt.asForEachStatement().setLoopBlock(statement);
    }
    return configureNode(forStmt, ctx);
  }

  @Override
  public Statement visitForControl(ProcessJParser.ForControlContext ctx) {
    if (ctx.enhancedForControl() != null) {
      return visitEnhancedForControl(ctx.enhancedForControl());
    }
    ForStatement forStmt = new ForStatement();
    if (ctx.forInit() != null) {
      forStmt.setInitialization(visitForInit(ctx.forInit()));
    }
    if (ctx.expression() != null) {
      Expression<?> conditional = (Expression<?>) visit(ctx.expression());
      BooleanExpression booleanExpr = configureNode(new BooleanExpression(conditional), conditional);
      forStmt.setCondition(booleanExpr);
    }
    if (ctx.forUpdate != null) {
      forStmt.setUpdate(visitExpressionList(ctx.forUpdate));
    }
    return forStmt;
  }

  @Override
  public ForEachStatement visitEnhancedForControl(ProcessJParser.EnhancedForControlContext ctx) {
    Parameter parameter = new Parameter();
    NodeType type = createNodeType(visitType_(ctx.type_()));
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
    if (tuple.isTuple1()) {
      Tuple1<String> t1 = tuple.asTuple1();
      parameter.setName(t1.getV1());
      parameter.setNodeType(type);
      configureNode(parameter, ctx.variableDeclaratorIdentifier());
    } else {
      Tuple2<String, ArrayType> t2 = tuple.asTuple2();
      ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
      arrayNode.setBracketPosition(ArrayNode.BracketPosition.NAME);
      setBaseType(type, arrayNode);
      parameter.setNodeType(arrayNode);
      parameter.setName(t2.getV1());
      configureNode(parameter, ctx);
    }
    return new ForEachStatement(parameter, expression);
  }

  @Override
  public Sequence<Expression<?>> visitForInit(ProcessJParser.ForInitContext ctx) {
    if (ctx.localVariableDeclaration() != null) {
      Sequence<VariableDeclarator> variables = visitLocalVariableDeclaration(ctx.localVariableDeclaration());
      Sequence<Expression<?>> declarations = Sequence.sequenceList();
      variables.forEach(v -> declarations.add(configureNode(new DeclarationExpression(v), v)));
      return declarations;
    }
    return visitExpressionList(ctx.expressionList());
  }

  @Override
  public Sequence<Expression<?>> visitExpressionList(ProcessJParser.ExpressionListContext ctx) {
    Sequence<Expression<?>> expressions = Sequence.sequenceList();
    ctx.expression().forEach(e -> expressions.add((Expression<?>) visit(e)));
    return expressions;
  }

  @Override
  public AltBlock visitAltStatement(ProcessJParser.AltStatementContext ctx) {
    Statement altBody = visitAltBody(ctx.altBody());
    AltBlock altStmt = new AltBlock();
    altStmt.setLoopBlock(altBody);
    altStmt.setFairAlt(ctx.PRI() != null);
    return configureNode(altStmt, ctx);
  }

  @Override
  public ReplicatedAltBlock visitAltForStatement(ProcessJParser.AltForStatementContext ctx) {
    ForStatement forStmt = visitForControl(ctx.forControl()).asForStatement();
    ReplicatedAltBlock replicatedAlt = new ReplicatedAltBlock();
    replicatedAlt.setInitialization(forStmt.getInitialization());
    replicatedAlt.setConditional(forStmt.getConditional());
    replicatedAlt.setUpdate(forStmt.getUpdate());
    replicatedAlt.setStatementLabels(forStmt.getStatementLabels().orElse(null));
    replicatedAlt.setLoopBlock(visitAltBody(ctx.altBody()));
    return configureNode(replicatedAlt, ctx);
  }

  @Override
  public BlockStatement visitAltBody(ProcessJParser.AltBodyContext ctx) {
    if (ctx.LBRACE() != null) {
      Sequence<Statement> altCases = Sequence.sequenceList();
      ctx.altCase().forEach(ac -> altCases.add(visitAltCase(ac)));
      return configureNode(new BlockStatement(altCases), ctx);
    }
    Statement altCase = visitAltCase(ctx.altCase(0));
    return configureNode(new BlockStatement(Sequence.sequenceList(altCase)), ctx);
  }

  @Override
  public AltCaseStatement visitAltCase(ProcessJParser.AltCaseContext ctx) {
    if (ctx.parExpression() != null && ctx.ANDAND() != null) {
      Expression<?> expression = (Expression<?>) visit(ctx.parExpression());
      Guard guard = visitAltGuard(ctx.altGuard());
      Statement statement = (Statement) visit(ctx.statement());
      AltCaseStatement altCase = new AltCaseStatement(expression, guard, statement);
      return configureNode(altCase, ctx);
    }
    if (ctx.altGuard() != null) {
      Guard guard = visitAltGuard(ctx.altGuard());
      Statement statement = (Statement) visit(ctx.statement());
      AltCaseStatement altCase = new AltCaseStatement(guard, statement);
      return configureNode(altCase, ctx);
    }
    Statement statement = (Statement) visit(ctx.statement());
    AltCaseStatement altCase = new AltCaseStatement(statement);
    return configureNode(altCase, ctx);
  }

  @Override
  public Guard visitAltGuard(ProcessJParser.AltGuardContext ctx) {
    Guard guard = new Guard();
    if (ctx.SKIP_() != null) {
      guard.setSkip(true);
      return configureNode(guard, ctx);
    }
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    guard.setExpression(expression);
    return configureNode(guard, ctx);
  }

  @Override
  public ParBlock visitParStatement(ProcessJParser.ParStatementContext ctx) {
    Sequence<Expression<?>> barriers = Sequence.sequenceList();
    if (ctx.ENROLL() != null) {
      barriers.addAll(visitExpressionList(ctx.expressionList()));
    }
    ParBlock parBlock = new ParBlock();
    parBlock.setBarriers(barriers);
    parBlock.setLoopBlock((Statement) visit(ctx.statement()));
    return configureNode(parBlock, ctx);
  }

  @Override
  public ParForBlock visitParForStatement(ProcessJParser.ParForStatementContext ctx) {
    ForStatement forStmt = visitForControl(ctx.forControl()).asForStatement();
    ParForBlock parBlock = new ParForBlock();
    parBlock.setInitialization(forStmt.getInitialization());
    parBlock.setConditional(forStmt.getConditional());
    parBlock.setUpdate(forStmt.getUpdate());
    parBlock.setStatementLabels(forStmt.getStatementLabels().orElse(null));
    parBlock.setLoopBlock((Statement) visit(ctx.statement()));
    return configureNode(parBlock, ctx);
  }

  @Override
  public WhileStatement visitWhileStatement(ProcessJParser.WhileStatementContext ctx) {
    Expression<?> conditional = (Expression<?>) visit(ctx.parExpression());
    Statement statement = (Statement) visit(ctx.statement());
    BooleanExpression booleanExpr = configureNode(new BooleanExpression(conditional), conditional);
    WhileStatement whileStmt = new WhileStatement(booleanExpr, statement);
    return configureNode(whileStmt, ctx);
  }

  @Override
  public DoWhileStatement visitDoStatement(ProcessJParser.DoStatementContext ctx) {
    Statement loopBlock = (Statement) visit(ctx.statement());
    Expression<?> conditional = visitParExpression(ctx.parExpression());
    BooleanExpression booleanExpr = configureNode(new BooleanExpression(conditional), conditional);
    DoWhileStatement doStmt = new DoWhileStatement(booleanExpr, loopBlock);
    return configureNode(doStmt, ctx);
  }

  @Override
  public SwitchStatement visitSwitchStatement(ProcessJParser.SwitchStatementContext ctx) {
    Expression<?> expression = visitParExpression(ctx.parExpression());
    Sequence<SwitchCaseStatement> cases = Sequence.sequenceList();
    ctx.switchBlockStatementGroup().forEach(c -> cases.add(visitSwitchBlockStatementGroup(c)));
    if (ctx.switchLabel() != null) {
      ctx.switchLabel().forEach(l -> {
        Expression<?> expr = visitSwitchLabel(l);
        cases.add(configureNode(new SwitchCaseStatement(Sequence.sequenceList(expr)), expr));
      });
    }
    SwitchStatement switchStmt = new SwitchStatement(expression, cases);
    return configureNode(switchStmt, ctx);
  }

  @Override
  public SwitchCaseStatement visitSwitchBlockStatementGroup(ProcessJParser.SwitchBlockStatementGroupContext ctx) {
    Sequence<Expression<?>> labels = Sequence.sequenceList();
    ctx.switchLabel().forEach(l -> labels.add(visitSwitchLabel(l)));
    Sequence<Statement> statements = Sequence.sequenceList();
    ctx.blockStatement().forEach(s -> statements.addAll(visitBlockStatement(s)));
    SwitchCaseStatement caseStmt = new SwitchCaseStatement(labels, statements);
    return configureNode(caseStmt, ctx);
  }

  @Override
  public Expression<?> visitSwitchLabel(ProcessJParser.SwitchLabelContext ctx) {
    if (ctx.expression() != null) {
      return (Expression<?>) visit(ctx.expression());
    }
    // an empty expression implies that there is a default case
    return configureNode(new EmptyExpression(), ctx.DEFAULT());
  }

  @Override
  public ReturnStatement visitReturnStatement(ProcessJParser.ReturnStatementContext ctx) {
    ReturnStatement returnStmt = new ReturnStatement();
    if (ctx.expression() != null) {
      returnStmt.setExpression((Expression<?>) visit(ctx.expression()));
    }
    return configureNode(returnStmt, ctx);
  }

  @Override
  public BreakStatement visitBreakStatement(ProcessJParser.BreakStatementContext ctx) {
    BreakStatement breakStmt = new BreakStatement();
    if (ctx.Identifier() != null) {
      breakStmt.setLabel(ctx.Identifier().getText());
    }
    return configureNode(breakStmt, ctx);
  }

  @Override
  public ContinueStatement visitContinueStatement(ProcessJParser.ContinueStatementContext ctx) {
    ContinueStatement continueStmt = new ContinueStatement();
    if (ctx.Identifier() != null) {
      continueStmt.setLabel(ctx.Identifier().getText());
    }
    return configureNode(continueStmt, ctx);
  }

  @Override
  public Object visitSeqStatement(ProcessJParser.SeqStatementContext ctx) {
    return null;
  }

  @Override
  public SkipStatement visitSkipStatement(ProcessJParser.SkipStatementContext ctx) {
    return configureNode(new SkipStatement(), ctx);
  }

  @Override
  public StopStatement visitStopStatement(ProcessJParser.StopStatementContext ctx) {
    return configureNode(new StopStatement(), ctx);
  }

  @Override
  public EmptyStatement visitEmptyStatement(ProcessJParser.EmptyStatementContext ctx) {
    return configureNode(new EmptyStatement(), ctx);
  }

  @Override
  public ExpressionStatement visitStatementExpression(ProcessJParser.StatementExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    ExpressionStatement expressionStmt = new ExpressionStatement(expression);
    return configureNode(expressionStmt, ctx);
  }

  @Override
  public LabelStatement visitLabelStatement(ProcessJParser.LabelStatementContext ctx) {
    Sequence<Label> labels = Sequence.sequenceList();
    for (int i = 0; i < ctx.Identifier().size(); ++i) {
      labels.add(configureNode(new Label(ctx.Identifier(i).getText()), ctx.Identifier(i).getSymbol()));
    }
    LabelStatement labelStatement = new LabelStatement((Statement) visit(ctx.statement()));
    labelStatement.setStatementLabels(labels);
    return configureNode(labelStatement, ctx);
  }

  @Override
  public Expression<?> visitPrimary(ProcessJParser.PrimaryContext ctx) {
    if (ctx.LPAREN() != null) {
      Expression<?> expression = (Expression<?>) visit(ctx.expression());
      GroupExpression group = new GroupExpression(expression);
      return configureNode(group, ctx);
    }
    if (ctx.literal() != null) {
      return visitLiteral(ctx.literal());
    }
    return visitIdentifier(ctx.identifier());
  }

  @Override
  public ConstantExpression visitLiteral(ProcessJParser.LiteralContext ctx) {
    ConstantExpression literal = new NullLiteral("null");
    if (ctx.IntegerLiteral() != null) {
      literal = new IntegerLiteral(ctx.getText());
    }
    if (ctx.FloatingPointLiteral() != null) {
      literal = new FloatLiteral(ctx.getText());
    }
    if (ctx.BooleanLiteral() != null) {
      literal = new BooleanLiteral(ctx.getText());
    }
    if (ctx.CharacterLiteral() != null) {
      literal = new CharacterLiteral(ctx.getText());
    }
    if (ctx.StringLiteral() != null) {
      literal = new StringLiteral(ctx.getText());
    }
    return configureNode(literal, ctx);
  }

  @Override
  public VariableExpression visitIdentifier(ProcessJParser.IdentifierContext ctx) {
    VariableExpression identifier = new VariableExpression();
    identifier.setName(ctx.getText());
    return configureNode(identifier, ctx);
  }

  @Override
  public Expression<?> visitPrimaryExpression(ProcessJParser.PrimaryExpressionContext ctx) {
    return visitPrimary(ctx.primary());
  }

  @Override
  public Expression<?> visitAnnotatedExpression(ProcessJParser.AnnotatedExpressionContext ctx) {
    return null;
  }

  @Override
  public Expression<?> visitArrayAccessExpression(ProcessJParser.ArrayAccessExpressionContext ctx) {
    Expression<?> name = (Expression<?>) visit(ctx.name);
    Expression<?> index = (Expression<?>) visit(ctx.index);
    ArrayAccess arrayAccess = new ArrayAccess(name, index);
    if (name.isNewArrayExpression()) {
      NewArrayExpression newArray = name.asNewArrayExpression();
      ArrayDimension dims = configureNode(new ArrayDimension(index), index);
      if (newArray.getLevels().isPresent()) {
        newArray.getLevels().get().add(dims);
      } else {
        newArray.setLevels(Sequence.sequenceList(dims));
      }
      return newArray;
    }
    return configureNode(arrayAccess, ctx);
  }


  @Override
  public Expression<?> visitMemberAccessExpression(ProcessJParser.MemberAccessExpressionContext ctx) {
    Expression<?> scope = (Expression<?>) visit(ctx.expression());
    if (ctx.identifier() != null) {
      VariableExpression identifier = visitIdentifier(ctx.identifier());
      FieldExpression fieldExpr = new FieldExpression(scope, identifier.getName());
      return configureNode(fieldExpr, ctx);
    }
    CallabelExpression invocation = visitInvocation(ctx.invocation());
    invocation.setMethodExpression(scope);
    return configureNode(invocation, ctx);
  }

  @Override
  public CallabelExpression visitInvocation(ProcessJParser.InvocationContext ctx) {
    VariableExpression variable = visitIdentifier(ctx.identifier());
    Expression<?> arguments = visitArguments(ctx.arguments());
    if (variable.getName().equals("read")) {
      ChannelReadExpression chanRead = new ChannelReadExpression();
      if (arguments.isBlockExpression()) {
        chanRead.setExtendedRV(arguments.asBlockExpression());
      } else {
        // Note that a channel-read expression must always have an
        // empty sequence of expression, otherwise, this is an error
        chanRead.setArguments(Sequence.sequenceList(arguments));
      }
      chanRead.setChannel(variable);
      return configureNode(chanRead, ctx);
    }
    if (variable.getName().equals("write")) {
      ChannelWriteExpression chanWrite = new ChannelWriteExpression();
      chanWrite.setChannel(variable);
      chanWrite.setExpression(arguments);
      return configureNode(chanWrite, ctx);
    }
    CallabelExpression invocation = new CallabelExpression();
    if (variable.getName().equals("timeout")) {
      invocation = new TimeoutReadExpression();
    }
    invocation.setIdentifier(variable.getName());
    if (arguments.isListExpression()) {
      if (arguments.asListExpression().getValues().isPresent()) {
        invocation.setArguments(arguments.asListExpression().getValues().get());
      }
    } else {
      invocation.setArguments(Sequence.sequenceList(arguments));
    }
    return configureNode(invocation, ctx);
  }

  @Override
  public Expression<?> visitArguments(ProcessJParser.ArgumentsContext ctx) {
    if (ctx.block() != null) {
      BlockExpression block = new BlockExpression(visitBlock(ctx.block()).getStatements());
      return configureNode(block, ctx);
    }
    ListExpression<?> arguments = new ListExpression<>();
    if (ctx.expressionList() != null) {
      arguments.setValues(visitExpressionList(ctx.expressionList()));
    }
    return configureNode(arguments, ctx);
  }

  @Override
  public PostfixExpression visitPostfixExpression(ProcessJParser.PostfixExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    final int op = ctx.DPLUS() != null ? PostfixExpression.PLUSPLUS : PostfixExpression.MINUSMINUS;
    PostfixExpression postfixExpr = new PostfixExpression(op, expression);
    return configureNode(postfixExpr, ctx);
  }

  @Override
  public PrefixExpression visitPrefixExpression(ProcessJParser.PrefixExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    final int op = ctx.DPLUS() != null
                   ? PrefixExpression.PLUSPLUS
                   : ctx.DMINUS() != null
                     ? PrefixExpression.MINUSMINUS
                     : ctx.PLUS() != null
                       ? PrefixExpression.PLUS
                       : ctx.MINUS() != null
                         ? PrefixExpression.MINUS
                         : ctx.COMP() != null
                           ? PrefixExpression.COMP
                           : PrefixExpression.NOT;
    PrefixExpression prefixExpr = new PrefixExpression(op, expression);
    return configureNode(prefixExpr, ctx);
  }

  @Override
  public CastExpression visitCastExpression(ProcessJParser.CastExpressionContext ctx) {
    Primitive type = visitPrimitiveType(ctx.primitiveType());
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    PrimitiveNode primitiveNode = configureNode(new PrimitiveNode(type), type);
    CastExpression castExpr = new CastExpression(primitiveNode, expression, false);
    return configureNode(castExpr, ctx);
  }

  @Override
  public Expression<?> visitObjectCreationExpression(ProcessJParser.ObjectCreationExpressionContext ctx) {
    return visitCreator(ctx.creator());
  }

  @Override
  public BinaryExpression visitMultiplicativeExpression(ProcessJParser.MultiplicativeExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    final int op = ctx.MULT() != null ? BinaryExpression.MULT : ctx.DIV() != null ? BinaryExpression.DIV : BinaryExpression.MOD;
    BinaryExpression binary = new BinaryExpression(left, right, op);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitAdditiveExpression(ProcessJParser.AdditiveExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    final int op = ctx.PLUS() != null
                   ? BinaryExpression.PLUS
                   : BinaryExpression.MINUS;
    BinaryExpression binary = new BinaryExpression(left, right, op);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitShiftExpression(ProcessJParser.ShiftExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    final int op = ctx.LT() != null
                   ? BinaryExpression.RSHIFT
                   : ctx.GT().size() > 2
                     ? BinaryExpression.RRSHIFT
                     : BinaryExpression.RSHIFT;
    BinaryExpression binary = new BinaryExpression(left, right, op);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitRelationalExpression(ProcessJParser.RelationalExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    final int op = ctx.LTEQ() != null
                   ? BinaryExpression.LTEQ
                   : ctx.GTEQ() != null
                     ? BinaryExpression.GTEQ
                     : ctx.GT() != null
                       ? BinaryExpression.GT
                       : BinaryExpression.LT;
    BinaryExpression binary = new BinaryExpression(left, right, op);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitInstanceofExpression(ProcessJParser.InstanceofExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpression binary = new BinaryExpression(left, right, BinaryExpression.INSTANCEOF);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitEqualityExpression(ProcessJParser.EqualityExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    final int op = ctx.EQEQ() != null
                   ? BinaryExpression.EQEQ
                   : BinaryExpression.NOTEQ;
    BinaryExpression binary = new BinaryExpression(left, right, op);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitAndExpression(ProcessJParser.AndExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpression binary = new BinaryExpression(left, right, BinaryExpression.AND);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitExclusiveExpression(ProcessJParser.ExclusiveExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpression binary = new BinaryExpression(left, right, BinaryExpression.XOR);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitInclusiveExpression(ProcessJParser.InclusiveExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpression binary = new BinaryExpression(left, right, BinaryExpression.OR);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitLogicalAndExpression(ProcessJParser.LogicalAndExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpression binary = new BinaryExpression(left, right, BinaryExpression.ANDAND);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpression visitLogicalOrExpression(ProcessJParser.LogicalOrExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpression binary = new BinaryExpression(left, right, BinaryExpression.OROR);
    return configureNode(binary, ctx);
  }

  @Override
  public TernaryExpression visitTernaryExpression(ProcessJParser.TernaryExpressionContext ctx) {
    Expression<?> conditional = (Expression<?>) visit(ctx.expression(0));
    Expression<?> trueBranch = (Expression<?>) visit(ctx.expression(1));
    Expression<?> falseBranch = (Expression<?>) visit(ctx.expression(2));
    BooleanExpression booleanExpr = configureNode(new BooleanExpression(conditional), conditional);
    TernaryExpression ternaryExpr = new TernaryExpression(booleanExpr, trueBranch, falseBranch);
    return configureNode(ternaryExpr, ctx);
  }

  @Override
  public AssignmentExpression visitAssignmentExpression(ProcessJParser.AssignmentExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    final int op = visitAssignOp(ctx.assignOp());
    AssignmentExpression assign = new AssignmentExpression(left, right, op);
    return configureNode(assign, ctx);
  }

  @Override
  public Integer visitAssignOp(ProcessJParser.AssignOpContext ctx) {
    if (ctx.EQ() != null) {
      return AssignmentExpression.EQ;
    }
    if (ctx.MULTEQ() != null) {
      return AssignmentExpression.MULTEQ;
    }
    if (ctx.DIVEQ() != null) {
      return AssignmentExpression.DIVEQ;
    }
    if (ctx.MODEQ() != null) {
      return AssignmentExpression.MODEQ;
    }
    if (ctx.PLUSEQ() != null) {
      return AssignmentExpression.PLUSEQ;
    }
    if (ctx.MINUSEQ() != null) {
      return AssignmentExpression.MINUSEQ;
    }
    if (ctx.LSHIFTEQ() != null) {
      return AssignmentExpression.LSHIFTEQ;
    }
    if (ctx.RSHIFTEQ() != null) {
      return AssignmentExpression.RSHIFTEQ;
    }
    if (ctx.RRSHIFTEQ() != null) {
      return AssignmentExpression.RRSHIFTEQ;
    }
    if (ctx.ANDEQ() != null) {
      return AssignmentExpression.ANDEQ;
    }
    if (ctx.XOREQ() != null) {
      return AssignmentExpression.XOREQ;
    }
    return AssignmentExpression.OREQ;
  }

  @Override
  public Expression<?> visitCreator(ProcessJParser.CreatorContext ctx) {
    SourceAST creatorName = visitCreatorName(ctx.creatorName());
    if (ctx.recordExpression() != null) {
      RecordLiteral record = new RecordLiteral();
      if (creatorName instanceof Name) {
        record.setName((Name) creatorName);
      } else if (creatorName instanceof Type) {
        record.setName(new Name(creatorName.asString())); // this is an error
      }
      record.setMembers(visitRecordExpression(ctx.recordExpression()));
      return configureNode(record, ctx);
    }
    if (ctx.protocolExpression() != null) {
      ProtocolLiteral protocol = visitProtocolExpression(ctx.protocolExpression());
      if (creatorName instanceof Name) {
        protocol.setName((Name) creatorName);
      } else if (creatorName instanceof Type) {
        protocol.setName(new Name(creatorName.asString())); // this is an error
      }
      return configureNode(protocol, ctx);
    }
    if (ctx.classExpression() != null) {
      // TODO:?
    }
    NewArrayExpression newArray = new NewArrayExpression();
    if (ctx.arrayExpression() != null) {
      newArray = visitArrayExpression(ctx.arrayExpression());
    }
    if (creatorName instanceof Type) {
      newArray.setNodeType(configureNode(new PrimitiveNode((Type) creatorName), creatorName));
    } else {
      // if it is not a primitive type then it must be the name of a constructed type
      NamedType name = new NamedType((Name) creatorName);
      newArray.setNodeType(configureNode(new ConstructedNode(name), creatorName));
    }
    return configureNode(newArray, ctx);
  }

  @Override
  public SourceAST visitCreatorName(ProcessJParser.CreatorNameContext ctx) {
    if (ctx.Identifier() != null) {
      return new Name(ctx.Identifier().getText());
    }
    if (ctx.typeName() != null) {
      return visitTypeName(ctx.typeName());
    }
    return visitPrimitiveType(ctx.primitiveType());
  }

  @Override
  public Sequence<RecordMemberLiteral> visitRecordExpression(ProcessJParser.RecordExpressionContext ctx) {
    Sequence<RecordMemberLiteral> members = Sequence.sequenceList();
    ctx.recordExpressionList().forEach(r -> members.add(visitRecordExpressionList(r)));
    return members;
  }

  @Override
  public RecordMemberLiteral visitRecordExpressionList(ProcessJParser.RecordExpressionListContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    RecordMemberLiteral member = new RecordMemberLiteral(name, expression);
    return configureNode(member, ctx);
  }

  @Override
  public ProtocolLiteral visitProtocolExpression(ProcessJParser.ProtocolExpressionContext ctx) {
    return visitProtocolExpressionList(ctx.protocolExpressionList());
  }

  @Override
  public ProtocolLiteral visitProtocolExpressionList(ProcessJParser.ProtocolExpressionListContext ctx) {
    final String identifier = ctx.Identifier().getText();
    Name tag = configureNode(new Name(identifier), ctx.Identifier());
    Sequence<RecordMemberLiteral> members = visitTagExpressionList(ctx.tagExpressionList());
    ProtocolLiteral protocol = new ProtocolLiteral();
    protocol.setTag(tag);
    protocol.setMembers(members);
    return protocol;
  }

  @Override
  public Sequence<RecordMemberLiteral> visitTagExpressionList(ProcessJParser.TagExpressionListContext ctx) {
    Sequence<RecordMemberLiteral> members = Sequence.sequenceList();
    ctx.recordExpressionList().forEach(r -> members.add(visitRecordExpressionList(r)));
    return members;
  }

  @Override
  public NewArrayExpression visitArrayExpression(ProcessJParser.ArrayExpressionContext ctx) {
    NewArrayExpression newArray = new NewArrayExpression();
    Sequence<ArrayDimension> dims = Sequence.sequenceList();
    if (ctx.arrayInitializer() != null) {
      ArrayInitializer initializer = visitArrayInitializer(ctx.arrayInitializer());
      ctx.LBRACK().forEach(l -> {
        EmptyExpression emptyExpr = new EmptyExpression(l.getSymbol());
        dims.add(configureNode(new ArrayDimension(emptyExpr), l));
      });
      newArray.setArrayInitializer(initializer);
      newArray.setLevels(dims);
      return configureNode(newArray, ctx);
    }
    ctx.expression().forEach(e -> {
      Expression<?> expression = (Expression<?>) visit(e);
      ArrayDimension dim = new ArrayDimension(expression);
      dims.add(configureNode(dim, e));
    });
    int diff = ctx.LBRACK().size() - ctx.expression().size();
    for (int i = 0; i < diff; ++i) {
      EmptyExpression emptyExpr = new EmptyExpression(ctx.LBRACK(i).getSymbol());
      dims.add(configureNode(new ArrayDimension(emptyExpr), ctx.LBRACK(i).getSymbol()));
    }
    newArray.setLevels(dims);
    return configureNode(newArray, ctx);
  }

  @Override
  public ArrayInitializer visitArrayInitializer(ProcessJParser.ArrayInitializerContext ctx) {
    ArrayInitializer arrayInitializer = new ArrayInitializer();
    Sequence<Expression<?>> values = visitVariableInitializerList(ctx.variableInitializerList());
    arrayInitializer.setValues(values);
    return configureNode(arrayInitializer, ctx);
  }

  @Override
  public Sequence<Expression<?>> visitVariableInitializerList(ProcessJParser.VariableInitializerListContext ctx) {
    Sequence<Expression<?>> expressions = Sequence.sequenceList();
    ctx.variableInitializer().forEach(e -> expressions.add((Expression<?>) visit(e)));
    return expressions;
  }

  @Override
  public Expression<?> visitVariableInitializer(ProcessJParser.VariableInitializerContext ctx) {
    if (ctx.expression() != null) {
      return (Expression<?>) visit(ctx.expression());
    }
    return visitArrayInitializer(ctx.arrayInitializer());
  }
}
