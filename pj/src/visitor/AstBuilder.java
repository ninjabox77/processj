package visitor;

import ast.*;
import ast.Package;
import ast.expr.*;
import ast.java.FieldDeclaration;
import ast.stmt.*;
import ast.toplevel.*;
import ast.types.*;
import misc.Tuple;
import misc.Tuple1;
import misc.Tuple2;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.TerminalNode;
import org.objectweb.asm.Opcodes;
import parser.ProcessJBaseVisitor;
import parser.ProcessJParser;
import typesystem.*;

import java.util.ArrayList;
import java.util.List;

import static misc.ConfigureAST.configureNode;


/**
 * Builds the AST from the parse tree generated by antlr4.
 *
 * @author Ben
 */
public class AstBuilder extends ProcessJBaseVisitor<Object> {

  private ArrayType getParentArray(ArrayType array) {
    while (!array.isOrphan()) {
      array = (ArrayType) array.getParentNode().get();
    }
    return array;
  }

  private ASTType createASTType(Type type) {
    if (type.isPrimitiveType()) {
      Primitive primitive = type.asPrimitiveType();
      PrimitiveNode primitiveNode = configureNode(new PrimitiveNode(), primitive);
      if (primitive.isByteType()) {
        primitiveNode.setTSType(primitive.asByteType());
      } else if (primitive.isIntegerType()) {
        primitiveNode.setTSType(primitive.asIntegerType());
      } else if (primitive.isShortType()) {
        primitiveNode.setTSType(primitive.asShortType());
      } else if (primitive.isBooleanType()) {
        primitiveNode.setTSType(primitive.asBooleanType());
      } else if (primitive.isLongType()) {
        primitiveNode.setTSType(primitive.asLongType());
      } else if (primitive.isFloatType()) {
        primitiveNode.setTSType(primitive.asFloatType());
      } else if (primitive.isDoubleType()) {
        primitiveNode.setTSType(primitive.asDoubleType());
      } else if (primitive.isCharType()) {
        primitiveNode.setTSType(primitive.asCharType());
      } else if (primitive.isTimerType()) {
        primitiveNode.setTSType(primitive.asTimerType());
      } else if (primitive.isBarrierType()) {
        primitiveNode.setTSType(primitive.asBarrierType());
      } else if (primitive.isStringType()) {
        primitiveNode.setTSType(primitive.asStringType());
      }
      return primitiveNode;
    } else if (type.isConstructedType()) {
      Constructed constructed = type.asConstructedType();
      if (constructed.isArrayType()) {
        ArrayType arrayType = constructed.asArrayType();
        ArrayNode arrayNode = configureNode(new ArrayNode(), arrayType);
        return arrayNode.setTSType(arrayType);
      } else if (constructed.isChannelType()) {
        ChannelType channelType = constructed.asChannelType();
        ChannelNode channelNode = configureNode(new ChannelNode(), channelType);
        return channelNode.setTSType(channelType);
      } else if (constructed.isChannelEndType()) {
        ChannelEndType channelEndType = constructed.asChannelEndType();
        ChannelEndNode channelEndNode = configureNode(new ChannelEndNode(), channelEndType);
        return channelEndNode.setTSType(channelEndType);
      } else if (constructed.isTypeVariable()) {
        TypeVariable typeVariable = constructed.asTypeVariable();
        ConstructedNode constructedNode = configureNode(new ConstructedNode(), typeVariable);
        return constructedNode.setTSType(typeVariable);
      }
      // types like protocol and record are resolved elsewhere
    }
    return null;
  }

  @Override
  public CompileUnit visitCompilationUnit(ProcessJParser.CompilationUnitContext ctx) {
    Package _package = null;
    if (ctx.packageDeclaration() != null) {
      _package = visitPackageDeclaration(ctx.packageDeclaration());
    }
    Sequence<Import> imports = Sequence.sequenceList();
    ctx.importDeclaration().forEach(i -> imports.add(visitImportDeclaration(i)));
    Sequence<TopLevelDeclaration<?>> typeDecls = Sequence.sequenceList();
    ctx.typeDeclaration().forEach(t -> typeDecls.add(visitTypeDeclaration(t)));
    CompileUnit compileUnit = new CompileUnit(_package, imports, typeDecls);
    return configureNode(compileUnit, ctx);
  }

  @Override
  public Package visitPackageDeclaration(ProcessJParser.PackageDeclarationContext ctx) {
    Package _package = new Package(visitPackageName(ctx.packageName()));
    return configureNode(_package, ctx);
  }

  @Override
  public Name visitPackageName(ProcessJParser.PackageNameContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    if (ctx.packageName() != null) {
      name.setQualifier(visitPackageName(ctx.packageName()));
    }
    return name;
  }

  @Override
  public Import visitImportDeclaration(ProcessJParser.ImportDeclarationContext ctx) {
    if (ctx.singleStaticImportDeclaration() != null) {
      return visitSingleTypeImportDeclaration(ctx.singleTypeImportDeclaration());
    }
    if (ctx.singleTypeMultiImportDeclaration() != null) {
      return visitSingleTypeMultiImportDeclaration(ctx.singleTypeMultiImportDeclaration());
    }
    if (ctx.singleStaticMultiImportDeclaration() != null) {
      return visitSingleStaticImportDeclaration(ctx.singleStaticImportDeclaration());
    }
    return visitSingleStaticMultiImportDeclaration(ctx.singleStaticMultiImportDeclaration());
  }

  @Override
  public Name visitTypeName(ProcessJParser.TypeNameContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    if (ctx.typeName() != null) {
      name.setQualifier(visitTypeName(ctx.typeName()));
    }
    return name;
  }

  @Override
  public Import visitSingleTypeImportDeclaration(ProcessJParser.SingleTypeImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    if (ctx.DCOLON() != null) {
      _import.setFieldName(ctx.Identifier().getText());
    }
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitSingleTypeMultiImportDeclaration(ProcessJParser.SingleTypeMultiImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    _import.setStar(true);
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitSingleStaticImportDeclaration(ProcessJParser.SingleStaticImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    if (ctx.DOT() != null) {
      _import.setFieldName(ctx.Identifier().getText());
    }
    _import.setJavaImport(true);
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitSingleStaticMultiImportDeclaration(ProcessJParser.SingleStaticMultiImportDeclarationContext ctx) {
    Import _import = new Import();
    _import.setName(visitTypeName(ctx.typeName()));
    _import.setStar(true);
    _import.setJavaImport(true);
    return configureNode(_import, ctx);
  }

  @Override
  public TopLevelDeclaration<?> visitTypeDeclaration(ProcessJParser.TypeDeclarationContext ctx) {
    if (ctx.procedureTypeDeclaration() != null) {
      return visitProcedureTypeDeclaration(ctx.procedureTypeDeclaration());
    }
    if (ctx.recordTypeDeclaration() != null) {
      return visitRecordTypeDeclaration(ctx.recordTypeDeclaration());
    }
    if (ctx.protocolTypeDeclaration() != null) {
      return visitProtocolTypeDeclaration(ctx.protocolTypeDeclaration());
    }
    if (ctx.constantDeclaration() != null) {
      return visitConstantDeclaration(ctx.constantDeclaration());
    }
    return null;
  }

  @Override
  public ProcedureTopLevel visitProcedureTypeDeclaration(ProcessJParser.ProcedureTypeDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    ASTType type = visitType_(ctx.type_());
    final String identifier = ctx.Identifier().getText();
    Sequence<Parameter> parameters = Sequence.sequenceList();
    if (ctx.formarlParameterList() != null) {
      parameters.addAll(visitFormarlParameterList(ctx.formarlParameterList()));
    }
    BlockStmt body = null;
    ProcedureTopLevel procedure = new ProcedureTopLevel();
    procedure.setModifiers(modifiers);
    procedure.setASTType(type);
    procedure.setName(identifier);
    procedure.setParameters(parameters);
    procedure.setBody(body);
    return configureNode(procedure, ctx);
  }

  @Override
  public Integer visitModifier(ProcessJParser.ModifierContext ctx) {
    if (ctx.PRIVATE() != null) {
      return Opcodes.ACC_PRIVATE;
    }
    if (ctx.PROTECTED() != null) {
      return Opcodes.ACC_PROTECTED;
    }
    if (ctx.CONST() != null) {
      return Opcodes.ACC_FINAL;
    }
    if (ctx.NATIVE() != null) {
      return Opcodes.ACC_NATIVE;
    }
    return Opcodes.ACC_PRIVATE;
  }

  @Override
  public ASTType visitType_(ProcessJParser.Type_Context ctx) {
    if (ctx.primitiveType() != null) {
      Primitive type = visitPrimitiveType(ctx.primitiveType());
      return configureNode(new PrimitiveNode(type), ctx);
    } else if (ctx.referenceType() != null) {
      Type type = visitReferenceType(ctx.referenceType());
      if (type.isConstructedType()) {
        Constructed ctr = type.asConstructedType();
        if (ctr.isArrayType()) {
          return configureNode(new ArrayNode(ctr.asArrayType()), ctx);
        } else if (ctr.isChannelType()) {
          return configureNode(new ChannelNode(ctr.asChannelType()), ctx);
        } else if (ctr.isChannelEndType()) {
          return configureNode(new ChannelEndNode(ctr.asChannelEndType()), ctx);
        } else if (ctr.isTypeVariable()) {
          return configureNode(new ConstructedNode(ctr.asTypeVariable()), ctx);
        }
      }
    } else if (ctx.classType() != null) {
      // TODO: this is for when a Java class is used
    }
    VoidType type = configureNode(new VoidType(), ctx);
    return configureNode(new VoidNode(type), ctx);
  }


  @Override
  public Primitive visitPrimitiveType(ProcessJParser.PrimitiveTypeContext ctx) {
    if (ctx.numericType() != null) {
      return visitNumericType(ctx.numericType());
    } else if (ctx.BOOLEAN() != null) {
      return configureNode(new BooleanType(), ctx);
    } else if (ctx.STRING() != null) {
      return configureNode(new StringType(), ctx);
    } else if (ctx.BARRIER() != null) {
      return configureNode(new BarrierType(), ctx);
    }
    return configureNode(new TimerType(), ctx);
  }

  @Override
  public Primitive visitNumericType(ProcessJParser.NumericTypeContext ctx) {
    if (ctx.integralType() != null) {
      return visitIntegralType(ctx.integralType());
    }
    return visitFloatingPointType(ctx.floatingPointType());
  }

  @Override
  public Primitive visitIntegralType(ProcessJParser.IntegralTypeContext ctx) {
    if (ctx.BYTE() != null) {
      return configureNode(new ByteType(), ctx);
    } else if (ctx.SHORT() != null) {
      return configureNode(new ShortType(), ctx);
    } else if (ctx.INT() != null) {
      return configureNode(new IntegerType(), ctx);
    } else if (ctx.LONG() != null) {
      return configureNode(new LongType(), ctx);
    }
    return configureNode(new CharType(), ctx);
  }

  @Override
  public Primitive visitFloatingPointType(ProcessJParser.FloatingPointTypeContext ctx) {
    if (ctx.FLOAT() != null) {
      return configureNode(new FloatType(), ctx);
    }
    return configureNode(new DoubleType(), ctx);
  }

  @Override
  public Type visitReferenceType(ProcessJParser.ReferenceTypeContext ctx) {
    if (ctx.arrayType() != null) {
      return configureNode(visitArrayType(ctx.arrayType()), ctx);
    } else if (ctx.channelType() != null) {
      return configureNode((Type) visit(ctx.channelType()), ctx);
    }
    return configureNode((Type) visit(ctx.typeVariable()), ctx);
  }

  @Override
  public ArrayType visitArrayType(ProcessJParser.ArrayTypeContext ctx) {
    ArrayType array = visitDims(ctx.dims());
    if (ctx.primitiveType() != null) {
      Type type = visitPrimitiveType(ctx.primitiveType());
      array.setComponentType(type);
    } else if (ctx.channelType() != null) {
      Type type = (Type) visit(ctx.channelType());
      array.setComponentType(type);
    } else if (ctx.typeVariable() != null) {
      Type type = (Type) visit(ctx.typeVariable());
      array.setComponentType(type);
    }
    return getParentArray(array);
  }

  // we build an array-type in reverse order so that in the body of
  // the caller we can set its component-type; e.g.:
  //
  //   ArrayType(ArrayType(ArrayType(<component-type>)))
  //
  // where component-type can be an atomic or constructed type
  @Override
  public ArrayType visitDims(ProcessJParser.DimsContext ctx) {
    ArrayType outerType = configureNode(new ArrayType(), ctx.LBRACK(0));
    for (int i = 1; i < ctx.LBRACK().size(); ++i) {
      ArrayType innerType = configureNode(new ArrayType(), ctx.LBRACK(i));
      outerType.setComponentType(innerType);
      outerType = innerType;
    }
    return outerType;
  }

  @Override
  public ChannelType visitChannelSharedReadType(ProcessJParser.ChannelSharedReadTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_READ);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedWriteType(ProcessJParser.ChannelSharedWriteTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_WRITE);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedType(ProcessJParser.ChannelSharedTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelType_(ProcessJParser.ChannelType_Context ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.NON_SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotRead(ProcessJParser.ChannelDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotWrite(ProcessJParser.ChannelDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public Object visitChannelSharedDotRead(ProcessJParser.ChannelSharedDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public Object visitChannelSharedDotWrite(ProcessJParser.ChannelSharedDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public TypeVariable visitTypeVariableIdentifier(ProcessJParser.TypeVariableIdentifierContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    return configureNode(new TypeVariable(name), ctx);
  }

  @Override
  public Sequence<Parameter> visitFormarlParameterList(ProcessJParser.FormarlParameterListContext ctx) {
    Sequence<Parameter> parameters = Sequence.sequenceList();
    if (ctx.formalParameters() != null) {
      parameters.addAll(visitFormalParameters(ctx.formalParameters()));
    }
    if (ctx.lastFormalDeclaration() != null) {
      parameters.add(visitLastFormalDeclaration(ctx.lastFormalDeclaration()));
    }
    return parameters;
  }

  @Override
  public Sequence<Parameter> visitFormalParameters(ProcessJParser.FormalParametersContext ctx) {
    Sequence<Parameter> params = Sequence.sequenceList();
    ctx.formalParameter().forEach(p -> params.add(visitFormalParameter(p)));
    return params;
  }

  @Override
  public Parameter visitFormalParameter(ProcessJParser.FormalParameterContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.variableModifier().size(); ++i) {
      Object obj = visitVariableModifier(ctx.variableModifier(i));
      if (obj instanceof Integer) {
        modifiers += (Integer) obj;
      }
    }
    Parameter parameter = new Parameter();
    parameter.setModifiers(modifiers);
    ASTType type = visitType_(ctx.type_());
    Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
    if (tuple.isTuple1()) {
      Tuple1<String> t1 = tuple.asTuple1();
      parameter.setName(t1.getV1());
      parameter.setASTType(type);
      configureNode(parameter, ctx.variableDeclaratorIdentifier());
    } else {
      Tuple2<String, ArrayType> t2 = tuple.asTuple2();
      ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
      arrayNode.getTSType().setTSType(type.getTSType());
      parameter.setASTType(arrayNode);
      parameter.setName(t2.getV1());
      configureNode(parameter, ctx);
    }
    return parameter;
  }

  @Override
  public Parameter visitLastFormalDeclaration(ProcessJParser.LastFormalDeclarationContext ctx) {
    if (ctx.type_() != null) {
      Parameter parameter = new Parameter();
      ASTType type = visitType_(ctx.type_());
      Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
      if (tuple.isTuple1()) {
        Tuple1<String> t1 = tuple.asTuple1();
        ArrayType arrayType = configureNode(new ArrayType(type.getTSType()), type);
        ArrayNode arrayNode = configureNode(new ArrayNode(arrayType), arrayType);
        parameter.setName(t1.getV1());
        parameter.setASTType(arrayNode);
        configureNode(parameter, ctx.variableDeclaratorIdentifier());
      } else {
        Tuple2<String, ArrayType> t2 = tuple.asTuple2();
        ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
        ErrorNode errorNode = new ErrorNode(arrayNode.getTSType());
        parameter.setASTType(configureNode(errorNode, arrayNode));
        parameter.setName(t2.getV1());
        configureNode(parameter, ctx);
      }
      parameter.setVarargs(true);
      return parameter;
    }
    return visitFormalParameter(ctx.formalParameter());
  }

  @Override
  public Tuple<?> visitVariableDeclaratorIdentifier(ProcessJParser.VariableDeclaratorIdentifierContext ctx) {
    String name = ctx.Identifier().getText();
    if (ctx.dims() != null) {
      ArrayType type = visitDims(ctx.dims());
      return Tuple2.tuple(name, type);
    }
    return Tuple1.tuple(name);
  }

  @Override
  public Object visitVariableModifier(ProcessJParser.VariableModifierContext ctx) {
    // TODO: annotations?
    if (ctx.CONST() != null) {
      return Opcodes.ACC_FINAL;
    }
    return null;
  }

  @Override
  public RecordDecl visitRecordTypeDeclaration(ProcessJParser.RecordTypeDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    final String identifier = ctx.Identifier().getText();
    Sequence<FieldDeclaration> fields = visitRecordBody(ctx.recordBody());
    // TODO: extends
    RecordDecl recordDecl = new RecordDecl();
    recordDecl.setModifiers(modifiers);
    recordDecl.setName(identifier);
    recordDecl.setDeclaredFields(fields);
    return configureNode(recordDecl, ctx);
  }

  @Override
  public Object visitExtends(ProcessJParser.ExtendsContext ctx) {
    return null;
  }

  @Override
  public Sequence<FieldDeclaration> visitRecordBody(ProcessJParser.RecordBodyContext ctx) {
    Sequence<FieldDeclaration> fields = Sequence.sequenceList();
    ctx.recordMemberDeclaration().forEach(r -> fields.addAll(visitRecordMemberDeclaration(r)));
    return fields;
  }

  @Override
  public Sequence<FieldDeclaration> visitRecordMemberDeclaration(ProcessJParser.RecordMemberDeclarationContext ctx) {
    Sequence<FieldDeclaration> fields = Sequence.sequenceList();
    ASTType type = visitType_(ctx.type_());
    List<Tuple<?>> variables = visitRecordMemberDeclarators(ctx.recordMemberDeclarators());
    for (Tuple<?> v : variables) {
      VariableDecl variableDecl = new VariableDecl();
      if (v.isTuple1()) {
        Tuple1<String> t1 = v.asTuple1();
        variableDecl.setName(t1.getV1());
        variableDecl.setASTType(type);
        configureNode(variableDecl, ctx.recordMemberDeclarators());
      } else {
        Tuple2<String, ArrayType> t2 = v.asTuple2();
        ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
        arrayNode.getTSType().setTSType(type.getTSType());
        variableDecl.setASTType(arrayNode);
        variableDecl.setName(t2.getV1());
        configureNode(variableDecl, ctx);
      }
      fields.add(configureNode(new FieldDeclaration(variableDecl), ctx));
    }
    return fields;
  }

  @Override
  public List<Tuple<?>> visitRecordMemberDeclarators(ProcessJParser.RecordMemberDeclaratorsContext ctx) {
    List<Tuple<?>> variables = new ArrayList<>();
    ctx.recordMemberDeclarator().forEach(r -> variables.add(visitRecordMemberDeclarator(r)));
    return variables;
  }

  @Override
  public Tuple<?> visitRecordMemberDeclarator(ProcessJParser.RecordMemberDeclaratorContext ctx) {
    return visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
  }

  @Override
  public ProtocolDecl visitProtocolTypeDeclaration(ProcessJParser.ProtocolTypeDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.modifier().size(); ++i) {
      modifiers += visitModifier(ctx.modifier(i));
    }
    final String identifier = ctx.Identifier().getText();
    ProtocolDecl protocolDecl = new ProtocolDecl();
    protocolDecl.setModifiers(modifiers);
    protocolDecl.setName(identifier);
    // TODO: extends?
    if (ctx.protocolBody() != null) {
      protocolDecl.setDeclaredTags(visitProtocolBody(ctx.protocolBody()));
    }
    return configureNode(protocolDecl, ctx);
  }

  @Override
  public Sequence<ProtocolCaseDecl> visitProtocolBody(ProcessJParser.ProtocolBodyContext ctx) {
    Sequence<ProtocolCaseDecl> cases = Sequence.sequenceList();
    ctx.protocolCase().forEach(c -> cases.add(visitProtocolCase(c)));
    return cases;
  }

  @Override
  public ProtocolCaseDecl visitProtocolCase(ProcessJParser.ProtocolCaseContext ctx) {
    final String identifier = ctx.Identifier().getText();
    Sequence<FieldDeclaration> fields = visitRecordBody(ctx.recordBody());
    ProtocolCaseDecl caseDecl = new ProtocolCaseDecl();
    caseDecl.setName(identifier);
    caseDecl.setDeclaredFields(fields);
    return configureNode(caseDecl, ctx);
  }

  @Override
  public ConstantDecl visitConstantDeclaration(ProcessJParser.ConstantDeclarationContext ctx) {
    return null;
  }

  @Override
  public Object visitConstantDeclarators(ProcessJParser.ConstantDeclaratorsContext ctx) {
    return null;
  }

  @Override
  public Object visitConstantDeclarator(ProcessJParser.ConstantDeclaratorContext ctx) {
    return null;
  }

  // Statements

  @Override
  public BlockStmt visitBlockAsStatement(ProcessJParser.BlockAsStatementContext ctx) {
    return visitBlock(ctx.block());
  }

  @Override
  public BlockStmt visitBlock(ProcessJParser.BlockContext ctx) {
    Sequence<Statement> stmt = Sequence.sequenceList();
    if (ctx.blockStatement() != null) {
      ctx.blockStatement().forEach(s -> stmt.addAll(visitBlockStatement(s)));
    }
    return configureNode(new BlockStmt(stmt), ctx);
  }

  @Override
  public Sequence<Statement> visitBlockStatement(ProcessJParser.BlockStatementContext ctx) {
    if (ctx.localVariableDeclarationStatement() != null) {
      return visitLocalVariableDeclarationStatement(ctx.localVariableDeclarationStatement());
    }
    Statement stat = (Statement) visit(ctx.statement());
    return null;
  }

  @Override
  public Sequence<Statement> visitLocalVariableDeclarationStatement(ProcessJParser.LocalVariableDeclarationStatementContext ctx) {
    Sequence<Statement> stmts = Sequence.sequenceList();
    Sequence<VariableDecl> variables = visitLocalVariableDeclaration(ctx.localVariableDeclaration());
    variables.forEach(v -> {
      DeclarationExpr declarationExpr = configureNode(new DeclarationExpr(v), v);
      ExpressionStmt expressionStmt = new ExpressionStmt(declarationExpr);
      stmts.add(configureNode(expressionStmt, v));
    });
    return null;
  }

  @Override
  public Sequence<VariableDecl> visitLocalVariableDeclaration(ProcessJParser.LocalVariableDeclarationContext ctx) {
    int modifiers = 0;
    for (int i = 0; i < ctx.variableModifier().size(); ++i) {
      Object obj = visitVariableModifier(ctx.variableModifier(i));
      if (obj instanceof Integer) {
        modifiers += (Integer) obj;
      }
    }
    ASTType type = visitType_(ctx.type_());
    Sequence<VariableDecl> variables = visitVariableDeclaratorList(ctx.variableDeclaratorList());
    for (VariableDecl v : variables) {
      if (v.getASTType() != null && v.getASTType().isArrayNode()) {
        v.getASTType().setASTType(type);
      } else {
        v.setASTType(type);
      }
      v.setModifiers(modifiers);
    }
    return variables;
  }

  @Override
  public Sequence<VariableDecl> visitVariableDeclaratorList(ProcessJParser.VariableDeclaratorListContext ctx) {
    Sequence<VariableDecl> variables = Sequence.sequenceList();
    ctx.variableDeclarator().forEach(v -> variables.add(visitVariableDeclarator(v)));
    return variables;
  }

  @Override
  public VariableDecl visitVariableDeclarator(ProcessJParser.VariableDeclaratorContext ctx) {
    VariableDecl variableDecl = new VariableDecl();
    Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
    if (tuple.isTuple1()) {
      Tuple1<String> t1 = tuple.asTuple1();
      variableDecl.setName(t1.getV1());
      configureNode(variableDecl, ctx.variableDeclaratorIdentifier());
    } else {
      Tuple2<String, ArrayType> t2 = tuple.asTuple2();
      ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
      variableDecl.setASTType(arrayNode);
      variableDecl.setName(t2.getV1());
      configureNode(variableDecl, ctx);
    }
    return configureNode(variableDecl, ctx);
  }

  @Override
  public IfStmt visitIfStatement(ProcessJParser.IfStatementContext ctx) {
    Expression<?> conditional = visitParExpression(ctx.parExpression());
    Statement thenPart = (Statement) visit(ctx.statement(0));
    Statement elsePart = null;
    if (ctx.ELSE() != null) {
      elsePart = (Statement) visit(ctx.statement(1));
    }
    BooleanExpr booleanExpr = configureNode(new BooleanExpr(conditional), conditional);
    IfStmt ifStmt = new IfStmt(booleanExpr, thenPart, elsePart);
    return configureNode(ifStmt, ctx);
  }

  @Override
  public Expression<?> visitParExpression(ProcessJParser.ParExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    return configureNode(expression, ctx);
  }

  @Override
  public Statement visitForStatement(ProcessJParser.ForStatementContext ctx) {
    Statement forStmt = visitForControl(ctx.forControl());
    Statement statement = (Statement) visit(ctx.statement());
    if (forStmt.isForStmt()) {
      forStmt.asForStmt().setLoopBlock(statement);
    } else {
      forStmt.asForEachStmt().setLoopBlock(statement);
    }
    return configureNode(forStmt, ctx);
  }

  @Override
  public Statement visitForControl(ProcessJParser.ForControlContext ctx) {
    if (ctx.enhancedForControl() != null) {
      // TODO: ??
    }
    ForStmt forStmt = new ForStmt();
    if (ctx.forInit() != null) {
      forStmt.setInitialization(visitForInit(ctx.forInit()));
    }
    if (ctx.expression() != null) {
      Expression<?> conditional = (Expression<?>) visit(ctx.expression());
      BooleanExpr booleanExpr = configureNode(new BooleanExpr(conditional), conditional);
      forStmt.setCondition(booleanExpr);
    }
    if (ctx.forUpdate != null) {
      forStmt.setUpdate(visitExpressionList(ctx.forUpdate));
    }
    return forStmt;
  }

  @Override
  public Object visitEnhancedForControl(ProcessJParser.EnhancedForControlContext ctx) {
    return null;
  }

  @Override
  public Sequence<Expression<?>> visitForInit(ProcessJParser.ForInitContext ctx) {
    if (ctx.localVariableDeclaration() != null) {
      Sequence<VariableDecl> variables = visitLocalVariableDeclaration(ctx.localVariableDeclaration());
      Sequence<Expression<?>> declarations = Sequence.sequenceList();
      variables.forEach(v -> declarations.add(configureNode(new DeclarationExpr(v), v)));
      return declarations;
    }
    return visitExpressionList(ctx.expressionList());
  }

  @Override
  public Sequence<Expression<?>> visitExpressionList(ProcessJParser.ExpressionListContext ctx) {
    Sequence<Expression<?>> expressions = Sequence.sequenceList();
    ctx.expression().forEach(e -> expressions.add((Expression<?>) visit(e)));
    return expressions;
  }

  @Override
  public RegularAltStmt visitAltStatement(ProcessJParser.AltStatementContext ctx) {
    Sequence<AltCase> altCases = visitAltBody(ctx.altBody());
    RegularAltStmt altStmt = new RegularAltStmt();
    altStmt.setAltCases(altCases);
    altStmt.setFairAlt(ctx.PRI() != null);
    return configureNode(altStmt, ctx);
  }

  @Override
  public ReplicatedAltStmt visitAltForStatement(ProcessJParser.AltForStatementContext ctx) {
    ForStmt forStmt = visitForControl(ctx.forControl()).asForStmt();
    ReplicatedAltStmt replicatedAlt = new ReplicatedAltStmt();
    replicatedAlt.setInitialization(forStmt.getInitialization());
    replicatedAlt.setConditional(forStmt.getConditional());
    replicatedAlt.setUpdate(forStmt.getUpdate());
    replicatedAlt.setStatementLabels(forStmt.getStatementLabels().orElse(null));
    replicatedAlt.setAltCases(visitAltBody(ctx.altBody()));
    return configureNode(replicatedAlt, ctx);
  }

  @Override
  public Sequence<AltCase> visitAltBody(ProcessJParser.AltBodyContext ctx) {
    Sequence<AltCase> altCases = Sequence.sequenceList();
    ctx.altCase().forEach(ac -> altCases.add(visitAltCase(ac)));
    return altCases;
  }

  @Override
  public AltCase visitAltCase(ProcessJParser.AltCaseContext ctx) {
    if (ctx.parExpression() != null && ctx.ANDAND() != null) {
      Expression<?> expression = (Expression<?>) visit(ctx.parExpression());
      Guard guard = visitAltGuard(ctx.altGuard());
      Statement statement = (Statement) visit(ctx.statement());
      AltCase altCase = new AltCase(expression, guard, statement);
      return configureNode(altCase, ctx);
    }
    if (ctx.altGuard() != null) {
      Guard guard = visitAltGuard(ctx.altGuard());
      Statement statement = (Statement) visit(ctx.statement());
      AltCase altCase = new AltCase(guard, statement);
      return configureNode(altCase, ctx);
    }
    Statement statement = (Statement) visit(ctx.statement());
    AltCase altCase = new AltCase(statement);
    return configureNode(altCase, ctx);
  }

  @Override
  public Guard visitAltGuard(ProcessJParser.AltGuardContext ctx) {
    Guard guard = new Guard();
    if (ctx.SKIP_() != null) {
      guard.setSkip(true);
      return configureNode(guard, ctx);
    }
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    guard.setExpression(expression);
    return configureNode(guard, ctx);
  }

  @Override
  public RegularParBlock visitParStatement(ProcessJParser.ParStatementContext ctx) {
    Sequence<Expression<?>> barriers = Sequence.sequenceList();
    if (ctx.ENROLL() != null) {
      barriers.addAll(visitExpressionList(ctx.expressionList()));
    }
    RegularParBlock parBlock = new RegularParBlock();
    parBlock.setBarriers(barriers);
    parBlock.setStatemetns(new Sequence<>((Statement) visit(ctx.statement())));
    return configureNode(parBlock, ctx);
  }

  @Override
  public ParForBlock visitParForStatement(ProcessJParser.ParForStatementContext ctx) {
    ForStmt forStmt = visitForControl(ctx.forControl()).asForStmt();
    ParForBlock parBlock = new ParForBlock();
    parBlock.setInitialization(forStmt.getInitialization());
    parBlock.setConditional(forStmt.getConditional());
    parBlock.setUpdate(forStmt.getUpdate());
    parBlock.setStatementLabels(forStmt.getStatementLabels().orElse(null));
    parBlock.setStatemetns(new Sequence<>((Statement) visit(ctx.statement())));
    return configureNode(parBlock, ctx);
  }

  @Override
  public WhileStmt visitWhileStatement(ProcessJParser.WhileStatementContext ctx) {
    Expression<?> conditional = (Expression<?>) visit(ctx.parExpression());
    Statement statement = (Statement) visit(ctx.statement());
    BooleanExpr booleanExpr = configureNode(new BooleanExpr(conditional), conditional);
    WhileStmt whileStmt = new WhileStmt(booleanExpr, statement);
    return configureNode(whileStmt, ctx);
  }

  @Override
  public Object visitSwitchStatement(ProcessJParser.SwitchStatementContext ctx) {
    Expression<?> expression = visitParExpression(ctx.parExpression());
    Sequence<SwitchCaseStmt> cases = Sequence.sequenceList();
    ctx.switchBlockStatementGroup().forEach(c -> cases.add(visitSwitchBlockStatementGroup(c)));
    return null;
  }

  @Override
  public SwitchCaseStmt visitSwitchBlockStatementGroup(ProcessJParser.SwitchBlockStatementGroupContext ctx) {
    Sequence<Expression<?>> labels = Sequence.sequenceList();
    ctx.switchLabel().forEach(l -> labels.add(visitSwitchLabel(l)));
    Sequence<Statement> statements = Sequence.sequenceList();
    ctx.blockStatement().forEach(s -> statements.addAll(visitBlockStatement(s)));
    SwitchCaseStmt caseStmt = new SwitchCaseStmt(labels, statements);
    return configureNode(caseStmt, ctx);
  }

  @Override
  public Expression<?> visitSwitchLabel(ProcessJParser.SwitchLabelContext ctx) {
    if (ctx.expression() != null) {
      return (Expression<?>) visit(ctx.expression());
    }
    // An empty expression implies that there is a default case
    return configureNode(new EmptyExpr(), ctx.DEFAULT());
  }

  @Override
  public ReturnStmt visitReturnStatement(ProcessJParser.ReturnStatementContext ctx) {
    ReturnStmt returnStmt = new ReturnStmt();
    if (ctx.expression() != null) {
      returnStmt.setExpression((Expression<?>) visit(ctx.expression()));
    }
    return configureNode(returnStmt, ctx);
  }

  @Override
  public BreakStmt visitBreakStatement(ProcessJParser.BreakStatementContext ctx) {
    BreakStmt breakStmt = new BreakStmt();
    if (ctx.Identifier() != null) {
      breakStmt.setLabel(ctx.Identifier().getText());
    }
    return configureNode(breakStmt, ctx);
  }

  @Override
  public ContinueStmt visitContinueStatement(ProcessJParser.ContinueStatementContext ctx) {
    ContinueStmt continueStmt = new ContinueStmt();
    if (ctx.Identifier() != null) {
      continueStmt.setLabel(ctx.Identifier().getText());
    }
    return configureNode(continueStmt, ctx);
  }

  @Override
  public EmptyStmt visitEmptyStatement(ProcessJParser.EmptyStatementContext ctx) {
    return configureNode(new EmptyStmt(), ctx);
  }

  @Override
  public ExpressionStmt visitStatementExpression(ProcessJParser.StatementExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    ExpressionStmt expressionStmt = new ExpressionStmt(expression);
    return configureNode(expressionStmt, ctx);
  }

  @Override
  public Object visitLabelStatement(ProcessJParser.LabelStatementContext ctx) {
    // TODO: ??
    return null;
  }

  @Override
  public Expression<?> visitPrimary(ProcessJParser.PrimaryContext ctx) {
    if (ctx.LPAREN() != null) {
      Expression<?> expression = (Expression<?>) visit(ctx.expression());
      GroupExpr group = new GroupExpr(expression);
      return configureNode(group, ctx);
    }
    if (ctx.literal() != null) {
      return visitLiteral(ctx.literal());
    }
    return visitIdentifier(ctx.identifier());
  }

  @Override
  public ConstantExpr visitLiteral(ProcessJParser.LiteralContext ctx) {
    ConstantExpr literal = new NullLiteral("null");
    if (ctx.IntegerLiteral() != null) {
      literal = new IntegerLiteral(ctx.getText());
    }
    if (ctx.FloatingPointLiteral() != null) {
      literal = new FloatLiteral(ctx.getText());
    }
    if (ctx.BooleanLiteral() != null) {
      literal = new BooleanLiteral(ctx.getText());
    }
    if (ctx.CharacterLiteral() != null) {
      literal = new CharLiteral(ctx.getText());
    }
    if (ctx.StringLiteral() != null) {
      literal = new StringLiteral(ctx.getText());
    }
    return configureNode(literal, ctx);
  }

  @Override
  public VariableExpr visitIdentifier(ProcessJParser.IdentifierContext ctx) {
    VariableExpr identifier = new VariableExpr();
    identifier.setName(ctx.getText());
    return configureNode(identifier, ctx);
  }

  @Override
  public Expression<?> visitAnnotatedExpression(ProcessJParser.AnnotatedExpressionContext ctx) {
    return null;
  }

  @Override
  public ArrayAccess visitArrayAccexxExpression(ProcessJParser.ArrayAccexxExpressionContext ctx) {
    Expression<?> name = (Expression<?>) visit(ctx.expression(0));
    Expression<?> index = (Expression<?>) visit(ctx.expression(1));
    ArrayAccess arrayAccess = new ArrayAccess(name, index);
    return configureNode(arrayAccess, ctx);
  }


  @Override
  public Expression<?> visitMemberAccessExpression(ProcessJParser.MemberAccessExpressionContext ctx) {
    Expression<?> scope = (Expression<?>) visit(ctx.expression());
    if (ctx.identifier() != null) {
      VariableExpr identifier = visitIdentifier(ctx.identifier());
      FieldExpr fieldExpr = new FieldExpr(scope, identifier.getName());
      return configureNode(fieldExpr, ctx);
    }
    CallableExpr invocation = visitInvocation(ctx.invocation());
    invocation.setMethodExpression(scope);
    return configureNode(invocation, ctx);
  }

  @Override
  public CallableExpr visitInvocation(ProcessJParser.InvocationContext ctx) {
    CallableExpr invocation = new CallableExpr();
    VariableExpr variable = visitIdentifier(ctx.identifier());
    switch (variable.getName()) {
      case "timeout" -> invocation = new TimeOutCallable();
      case "read" -> invocation = new ReadCallable();
      case "write" -> invocation = new WriteCallable();
    }
    invocation.setIdentifier(variable.getName());
    Expression<?> expression = visitArguments(ctx.arguments());
    if (expression.isListExpression()) {
      if (expression.asListExpression().getValues().isPresent()) {
        invocation.setArguments(expression.asListExpression().getValues().get());
      }
      return configureNode(invocation, ctx);
    }
    // Extended rendezvous
    invocation.setArguments(Sequence.sequenceList(expression));
    return configureNode(invocation, ctx);
  }

  @Override
  public Expression<?> visitArguments(ProcessJParser.ArgumentsContext ctx) {
    if (ctx.block() != null) {
      BlockExpr block = new BlockExpr(visitBlock(ctx.block()).getStatements());
      return configureNode(block, ctx);
    }
    ListExpression<?> arguments = new ListExpression<>();
    if (ctx.expressionList() != null) {
      arguments.setValues(visitExpressionList(ctx.expressionList()));
    }
    return configureNode(arguments, ctx);
  }

  @Override
  public PostfixExpr visitPostfixExpression(ProcessJParser.PostfixExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    PostfixExpr postfixExpr = new PostfixExpr(ctx.op, expression);
    return configureNode(postfixExpr, ctx);
  }

  @Override
  public PrefixExpr visitPrefixExpression(ProcessJParser.PrefixExpressionContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    PrefixExpr prefixExpr = new PrefixExpr(ctx.op, expression);
    return configureNode(prefixExpr, ctx);
  }

  @Override
  public CastExpr visitCastExpression(ProcessJParser.CastExpressionContext ctx) {
    Primitive type = visitPrimitiveType(ctx.primitiveType());
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    PrimitiveNode primitiveNode = configureNode(new PrimitiveNode(type), type);
    CastExpr castExpr = new CastExpr(primitiveNode, expression, false);
    return configureNode(castExpr, ctx);
  }

  @Override
  public BinaryExpr visitMultiplicativeExpression(ProcessJParser.MultiplicativeExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.op);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpr visitAdditiveExpression(ProcessJParser.AdditiveExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.op);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpr visitShiftExpression(ProcessJParser.ShiftExpressionContext ctx) {
    return null;
  }

  @Override
  public BinaryExpr visitRelationalExpression(ProcessJParser.RelationalExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.op);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpr visitInstanceofExpression(ProcessJParser.InstanceofExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.IS().getSymbol());
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpr visitEqualityExpression(ProcessJParser.EqualityExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.op);
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpr visitAndExpression(ProcessJParser.AndExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.AND().getSymbol());
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpr visitExclusiveExpression(ProcessJParser.ExclusiveExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.XOR().getSymbol());
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpr visitInclusiveExpression(ProcessJParser.InclusiveExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.OR().getSymbol());
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpr visitLogicalAndExpression(ProcessJParser.LogicalAndExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.ANDAND().getSymbol());
    return configureNode(binary, ctx);
  }

  @Override
  public BinaryExpr visitLogicalOrExpression(ProcessJParser.LogicalOrExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    BinaryExpr binary = new BinaryExpr(left, right, ctx.OROR().getSymbol());
    return configureNode(binary, ctx);
  }

  @Override
  public TernaryExpr visitTernaryExpression(ProcessJParser.TernaryExpressionContext ctx) {
    Expression<?> conditional = (Expression<?>) visit(ctx.expression(0));
    Expression<?> trueBranch = (Expression<?>) visit(ctx.expression(1));
    Expression<?> falseBranch = (Expression<?>) visit(ctx.expression(2));
    BooleanExpr booleanExpr = configureNode(new BooleanExpr(conditional), conditional);
    TernaryExpr ternaryExpr = new TernaryExpr(booleanExpr, trueBranch, falseBranch);
    return configureNode(ternaryExpr, ctx);
  }

  @Override
  public AssignmentExpr visitAssignmentExpression(ProcessJParser.AssignmentExpressionContext ctx) {
    Expression<?> left = (Expression<?>) visit(ctx.expression(0));
    Expression<?> right = (Expression<?>) visit(ctx.expression(1));
    Token op = visitAssignOp(ctx.assignOp()).getSymbol();
    AssignmentExpr assign = new AssignmentExpr(left, right, op);
    return configureNode(assign, ctx);
  }

  @Override
  public TerminalNode visitAssignOp(ProcessJParser.AssignOpContext ctx) {
    if (ctx.EQ() != null) {
      return ctx.EQ();
    }
    if (ctx.MULTEQ() != null) {
      return ctx.MULTEQ();
    }
    if (ctx.DIVEQ() != null) {
      return ctx.DIVEQ();
    }
    if (ctx.MODEQ() != null) {
      return ctx.MODEQ();
    }
    if (ctx.PLUSEQ() != null) {
      return ctx.PLUSEQ();
    }
    if (ctx.MINUSEQ() != null) {
      return ctx.MINUSEQ();
    }
    if (ctx.LSHIFTEQ() != null) {
      return ctx.LSHIFTEQ();
    }
    if (ctx.RSHIFTEQ() != null) {
      return ctx.RSHIFTEQ();
    }
    if (ctx.RRSHIFTEQ() != null) {
      return ctx.RRSHIFTEQ();
    }
    if (ctx.ANDEQ() != null) {
      return ctx.ANDEQ();
    }
    if (ctx.XOREQ() != null) {
      return ctx.XOREQ();
    }
    return ctx.OREQ();
  }

  @Override
  public Expression<?> visitCreator(ProcessJParser.CreatorContext ctx) {
    Node type = visitCreatorName(ctx.creatorName());
    if (ctx.recordExpression() != null) {
      RecordLiteral record = new RecordLiteral();
      if (type instanceof Name) {
        record.setName((Name) type);
      } else {
        // If it is not a type name or a class then it must be
        // a primitive type which should not be allowed.
        record.setASTType(configureNode(new ErrorNode((Type) type), type));
      }
      record.setMembers(visitRecordExpression(ctx.recordExpression()));
      return configureNode(record, ctx);
    }
    if (ctx.protocolExpression() != null) {
      ProtocolLiteral protocol = visitProtocolExpression(ctx.protocolExpression());
      if (type instanceof Name) {
        protocol.setName((Name) type);
      } else {
        // If it is not a type name or a class then it must be
        // a primitive type which should not be allowed.
        protocol.setASTType(configureNode(new ErrorNode((Type) type), type));
      }
      return configureNode(protocol, ctx);
    }
    if (ctx.arrayExpression() != null) {
      NewArrayExpr newArray = visitArrayExpression(ctx.arrayExpression());
      if (type instanceof Type) {
        newArray.setASTType(configureNode(new PrimitiveNode((Type) type), type));
      } else {
        // If it is not a primitive type then it must be a class or
        // type name of some sort.
        TypeVariable name = new TypeVariable((Name) type);
        newArray.setASTType(configureNode(new ConstructedNode(name), type));
      }
    }
    // TODO: class type??
    return null;
  }

  @Override
  public Node visitCreatorName(ProcessJParser.CreatorNameContext ctx) {
    if (ctx.Identifier() != null) {
      return new Name(ctx.Identifier().getText());
    }
    if (ctx.typeName() != null) {
      return visitTypeName(ctx.typeName());
    }
    return visitPrimitiveType(ctx.primitiveType());
  }

  @Override
  public Sequence<RecordMemberLiteral> visitRecordExpression(ProcessJParser.RecordExpressionContext ctx) {
    Sequence<RecordMemberLiteral> members = Sequence.sequenceList();
    ctx.recordExpressionList().forEach(r -> members.add(visitRecordExpressionList(r)));
    return members;
  }

  @Override
  public RecordMemberLiteral visitRecordExpressionList(ProcessJParser.RecordExpressionListContext ctx) {
    Expression<?> expression = (Expression<?>) visit(ctx.expression());
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    RecordMemberLiteral member = new RecordMemberLiteral(name, expression);
    return configureNode(member, ctx);
  }

  @Override
  public ProtocolLiteral visitProtocolExpression(ProcessJParser.ProtocolExpressionContext ctx) {
    return visitProtocolExpressionList(ctx.protocolExpressionList());
  }

  @Override
  public ProtocolLiteral visitProtocolExpressionList(ProcessJParser.ProtocolExpressionListContext ctx) {
    final String identifier = ctx.Identifier().getText();
    Name tag = configureNode(new Name(identifier), ctx.Identifier());
    Sequence<RecordMemberLiteral> members = visitTagExpressionList(ctx.tagExpressionList());
    ProtocolLiteral protocol = new ProtocolLiteral();
    protocol.setTag(tag);
    protocol.setMembers(members);
    return protocol;
  }

  @Override
  public Sequence<RecordMemberLiteral> visitTagExpressionList(ProcessJParser.TagExpressionListContext ctx) {
    Sequence<RecordMemberLiteral> members = Sequence.sequenceList();
    ctx.recordExpressionList().forEach(r -> members.add(visitRecordExpressionList(r)));
    return members;
  }

  @Override
  public NewArrayExpr visitArrayExpression(ProcessJParser.ArrayExpressionContext ctx) {
    NewArrayExpr newArray = new NewArrayExpr();
    Sequence<ArrayDimension> dims = Sequence.sequenceList();
    if (ctx.arrayInitializer() != null) {
      ArrayInitializer initializer = visitArrayInitializer(ctx.arrayInitializer());
      ctx.LBRACK().forEach(l -> {
        EmptyExpr emptyExpr = new EmptyExpr(l.getSymbol());
        dims.add(configureNode(new ArrayDimension(emptyExpr), l));
      });
      return configureNode(newArray, ctx);
    }
    ctx.expression().forEach(e -> {
      Expression<?> expression = (Expression<?>) visit(e);
      ArrayDimension dim = new ArrayDimension(expression);
      dims.add(configureNode(dim, e));
    });
    int diff = ctx.LBRACK().size() - ctx.expression().size();
    for (int i = 0; i < diff; ++i) {
      EmptyExpr emptyExpr = new EmptyExpr(ctx.LBRACK(i).getSymbol());
      dims.add(configureNode(new ArrayDimension(emptyExpr), ctx.LBRACK(i).getSymbol()));
    }
    return configureNode(newArray, ctx);
  }

  @Override
  public ArrayInitializer visitArrayInitializer(ProcessJParser.ArrayInitializerContext ctx) {
    ArrayInitializer arrayInitializer = new ArrayInitializer();
    return configureNode(arrayInitializer, ctx);
  }

  @Override
  public Sequence<Expression<?>> visitVariableInitializerList(ProcessJParser.VariableInitializerListContext ctx) {
    Sequence<Expression<?>> expressions = Sequence.sequenceList();
    ctx.variableInitializer().forEach(e -> expressions.add((Expression<?>) visit(e)));
    return expressions;
  }

  @Override
  public Expression<?> visitVariableInitializer(ProcessJParser.VariableInitializerContext ctx) {
    if (ctx.expression() != null) {
      return (Expression<?>) visit(ctx.expression());
    }
    return visitArrayInitializer(ctx.arrayInitializer());
  }
}
