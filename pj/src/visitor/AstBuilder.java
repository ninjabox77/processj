package visitor;

import ast.*;
import ast.Package;
import ast.expr.BinaryExpr;
import ast.expr.DeclarationExpr;
import ast.expr.Expression;
import ast.expr.VariableExpr;
import ast.java.FieldDeclaration;
import ast.toplevel.*;
import ast.types.*;
import misc.Tuple;
import misc.Tuple1;
import misc.Tuple2;
import org.objectweb.asm.Opcodes;
import parser.ProcessJBaseVisitor;
import parser.ProcessJParser;
import typesystem.*;

import static misc.ConfigureAST.*;

/**
 * Builds the AST from the parse tree generated by antlr4.
 *
 * @author Ben
 */
public class AstBuilder extends ProcessJBaseVisitor<Object> {

  private ArrayType getParentArray(ArrayType array) {
    while (!array.isOrphan()) {
      array = (ArrayType) array.getParentNode().get();
    }
    return array;
  }

  private ASTType createASTType(Type type) {
    if (type.isPrimitiveType()) {
      Primitive primitive = type.asPrimitiveType();
      PrimitiveNode primitiveNode = configureNode(new PrimitiveNode(), primitive);
      if (primitive.isByteType()) {
        primitiveNode.setTSType(primitive.asByteType());
      } else if (primitive.isIntegerType()) {
        primitiveNode.setTSType(primitive.asIntegerType());
      } else if (primitive.isShortType()) {
        primitiveNode.setTSType(primitive.asShortType());
      } else if (primitive.isBooleanType()) {
        primitiveNode.setTSType(primitive.asBooleanType());
      } else if (primitive.isLongType()) {
        primitiveNode.setTSType(primitive.asLongType());
      } else if (primitive.isFloatType()) {
        primitiveNode.setTSType(primitive.asFloatType());
      } else if (primitive.isDoubleType()) {
        primitiveNode.setTSType(primitive.asDoubleType());
      } else if (primitive.isCharType()) {
        primitiveNode.setTSType(primitive.asCharType());
      } else if (primitive.isTimerType()) {
        primitiveNode.setTSType(primitive.asTimerType());
      } else if (primitive.isBarrierType()) {
        primitiveNode.setTSType(primitive.asBarrierType());
      } else if (primitive.isStringType()) {
        primitiveNode.setTSType(primitive.asStringType());
      }
      return primitiveNode;
    } else if (type.isConstructedType()) {
      Constructed constructed = type.asConstructedType();
      if (constructed.isArrayType()) {
        ArrayType arrayType = constructed.asArrayType();
        ArrayNode arrayNode = configureNode(new ArrayNode(), arrayType);
        return arrayNode.setTSType(arrayType);
      } else if (constructed.isChannelType()) {
        ChannelType channelType = constructed.asChannelType();
        ChannelNode channelNode = configureNode(new ChannelNode(), channelType);
        return channelNode.setTSType(channelType);
      } else if (constructed.isChannelEndType()) {
        ChannelEndType channelEndType = constructed.asChannelEndType();
        ChannelEndNode channelEndNode = configureNode(new ChannelEndNode(), channelEndType);
        return channelEndNode.setTSType(channelEndType);
      } else if (constructed.isTypeVariable()) {
        TypeVariable typeVariable = constructed.asTypeVariable();
        ConstructedNode constructedNode = configureNode(new ConstructedNode(), typeVariable);
        return constructedNode.setTSType(typeVariable);
      }
      // types like protocol and record are resolved elsewhere
    }
    return null;
  }

  @Override
  public Object visitInit(ProcessJParser.InitContext ctx) {
    Package packet = visitPackageDeclaration(ctx.packageDeclaration());
    Sequence<Import> imports = Sequence.sequenceList();
    ctx.importDeclaration().forEach(i -> imports.add((Import) visit(i)));
    Sequence<TopLevelDeclaration<?>> topLevel = Sequence.sequenceList();
    ctx.typeDeclaration().forEach(t -> topLevel.add((TopLevelDeclaration<?>) visit(t)));
    return null;
  }

  @Override
  public Package visitPackageDeclaration(ProcessJParser.PackageDeclarationContext ctx) {
    Package packet = new Package(ctx.Identifier().getText());
    return configureNode(packet, ctx);
  }

  @Override
  public Name visitPackageAccess(ProcessJParser.PackageAccessContext ctx) {
    String ident = ctx.Identifier(0).getText();
    Name oldName = configureNode(new Name(ident), ctx.Identifier(0));
    for (int i = 1; i < ctx.Identifier().size(); ++i) {
      ident = ctx.Identifier(i).getText();
      Name newName = configureNode(new Name(ident), ctx.Identifier(i));
      newName.setQualifier(oldName);
      oldName = newName;
    }
    return configureNode(oldName, ctx);
  }

  @Override
  public Import visitSingleImportDeclaration(ProcessJParser.SingleImportDeclarationContext ctx) {
    Name name = new Name(ctx.Identifier(0).getText());
    configureNode(name, ctx.Identifier(0));
    Import _import = new Import().setName(name);
    if (ctx.Identifier().size() > 1) {
      _import.setFieldName(ctx.Identifier(1).getText());
    }
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitMultiImportDeclaration(ProcessJParser.MultiImportDeclarationContext ctx) {
    Name name = visitPackageAccess(ctx.packageAccess());
    Import _import = new Import().setName(name);
    if (ctx.Identifier() != null) {
      _import.setFieldName(ctx.Identifier().getText());
    }
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitMultiImportDeclarationStar(ProcessJParser.MultiImportDeclarationStarContext ctx) {
    Name name = visitPackageAccess(ctx.packageAccess());
    Import _import = new Import().setName(name).setStar(true);
    return configureNode(_import, ctx);
  }

  @Override
  public ProcedureTopLevel visitProcedureDeclaration(ProcessJParser.ProcedureDeclarationContext ctx) {
    int modifiers = Opcodes.ACC_PRIVATE;
    if (ctx.modifier() != null) {
      modifiers -= Opcodes.ACC_PRIVATE;
      for (int i = 0; i < ctx.modifier().size(); ++i) {
        modifiers += visitModifier(ctx.modifier(i));
      }
    }
    ASTType type = visitType_(ctx.type_());
    String procName = ctx.Identifier().toString();
    return null;
  }

  @Override
  public Integer visitModifier(ProcessJParser.ModifierContext ctx) {
    if (ctx.PRIVATE() != null) {
      return Opcodes.ACC_PRIVATE;
    }
    if (ctx.PROTECTED() != null) {
      return Opcodes.ACC_PROTECTED;
    }
    if (ctx.CONST() != null) {
      return Opcodes.ACC_FINAL;
    }
    if (ctx.NATIVE() != null) {
      return Opcodes.ACC_NATIVE;
    }
    return Opcodes.ACC_PRIVATE;
  }

  @Override
  public ASTType visitType_(ProcessJParser.Type_Context ctx) {
    if (ctx.primitiveType() != null) {
      Primitive type = visitPrimitiveType(ctx.primitiveType());
      return configureNode(new PrimitiveNode(type), ctx);
    } else if (ctx.referenceType() != null) {
      Type type = visitReferenceType(ctx.referenceType());
      if (type.isConstructedType()) {
        Constructed ctr = type.asConstructedType();
        if (ctr.isArrayType()) {
          return configureNode(new ArrayNode(ctr.asArrayType()), ctx);
        } else if (ctr.isChannelType()) {
          return configureNode(new ChannelNode(ctr.asChannelType()), ctx);
        } else if (ctr.isChannelEndType()) {
          return configureNode(new ChannelEndNode(ctr.asChannelEndType()), ctx);
        } else if (ctr.isTypeVariable()) {
          return configureNode(new ConstructedNode(ctr.asTypeVariable()), ctx);
        }
      }
    } else if (ctx.classType() != null) {
      // TODO: this is for when a Java class is used
    }
    VoidType type = configureNode(new VoidType(), ctx);
    return configureNode(new VoidNode(type), ctx);
  }

  @Override
  public Primitive visitPrimitiveType(ProcessJParser.PrimitiveTypeContext ctx) {
    if (ctx.numericType() != null) {
      return visitNumericType(ctx.numericType());
    } else if (ctx.BOOLEAN() != null) {
      return configureNode(new BooleanType(), ctx);
    } else if (ctx.STRING() != null) {
      return configureNode(new StringType(), ctx);
    } else if (ctx.BARRIER() != null) {
      return configureNode(new BarrierType(), ctx);
    }
    return configureNode(new TimerType(), ctx);
  }

  @Override
  public Primitive visitNumericType(ProcessJParser.NumericTypeContext ctx) {
    if (ctx.integralType() != null) {
      return visitIntegralType(ctx.integralType());
    }
    return visitFloatingPointType(ctx.floatingPointType());
  }

  @Override
  public Primitive visitIntegralType(ProcessJParser.IntegralTypeContext ctx) {
    if (ctx.BYTE() != null) {
      return configureNode(new ByteType(), ctx);
    } else if (ctx.SHORT() != null) {
      return configureNode(new ShortType(), ctx);
    } else if (ctx.INT() != null) {
      return configureNode(new IntegerType(), ctx);
    } else if (ctx.LONG() != null) {
      return configureNode(new LongType(), ctx);
    }
    return configureNode(new CharType(), ctx);
  }

  @Override
  public Primitive visitFloatingPointType(ProcessJParser.FloatingPointTypeContext ctx) {
    if (ctx.FLOAT() != null) {
      return configureNode(new FloatType(), ctx);
    }
    return configureNode(new DoubleType(), ctx);
  }

  @Override
  public Type visitReferenceType(ProcessJParser.ReferenceTypeContext ctx) {
    if (ctx.arrayType() != null) {
      return configureNode(visitArrayType(ctx.arrayType()), ctx);
    } else if (ctx.channelType() != null) {
      return configureNode((Type) visit(ctx.channelType()), ctx);
    }
    return configureNode((Type) visit(ctx.typeVariable()), ctx);
  }

  @Override
  public ArrayType visitArrayType(ProcessJParser.ArrayTypeContext ctx) {
    ArrayType array = visitDims(ctx.dims());
    if (ctx.primitiveType() != null) {
      Type type = visitPrimitiveType(ctx.primitiveType());
      array.setComponentType(type);
    } else if (ctx.channelType() != null) {
      Type type = (Type) visit(ctx.channelType());
      array.setComponentType(type);
    } else if (ctx.typeVariable() != null) {
      Type type = (Type) visit(ctx.typeVariable());
      array.setComponentType(type);
    }
    return getParentArray(array);
  }

  //
  // we build an array-type in reverse order so that in the body of
  // the caller we can set its component-type; e.g.:
  //
  //    ArrayType(ArrayType(ArrayType(<component-type>)))
  //
  // where component-type can be an atomic or constructed type
  //
  @Override
  public ArrayType visitDims(ProcessJParser.DimsContext ctx) {
    ArrayType outerType = configureNode(new ArrayType(), ctx.LBRACK(0));
    for (int i = 1; i < ctx.LBRACK().size(); ++i) {
      ArrayType innerType = configureNode(new ArrayType(), ctx.LBRACK(i));
      outerType.setComponentType(innerType);
      outerType = innerType;
    }
    return outerType;
  }

  @Override
  public ChannelType visitChannelSharedReadType(ProcessJParser.ChannelSharedReadTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_READ);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedWriteType(ProcessJParser.ChannelSharedWriteTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_WRITE);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedType(ProcessJParser.ChannelSharedTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelType_(ProcessJParser.ChannelType_Context ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.NON_SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotRead(ProcessJParser.ChannelDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotWrite(ProcessJParser.ChannelDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public Object visitChannelSharedDotRead(ProcessJParser.ChannelSharedDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public Object visitChannelSharedDotWrite(ProcessJParser.ChannelSharedDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public TypeVariable visitTypeVariableIdentifier(ProcessJParser.TypeVariableIdentifierContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    return configureNode(new TypeVariable(name), ctx);
  }

  @Override
  public TypeVariable visitTypeVariablePackageDotIdentifier(ProcessJParser.TypeVariablePackageDotIdentifierContext ctx) {
    Name name = new Name()
        .setQualifier(visitPackageAccess(ctx.packageAccess()))
        .setIdentifier(ctx.Identifier().getText());
    configureNode(name, ctx.packageAccess());
    return configureNode(new TypeVariable(name), ctx);
  }

  @Override
  public Object visitFormalDeclaration_(ProcessJParser.FormalDeclaration_Context ctx) {
    return null;
  }

  @Override
  public Object visitLastFormalDeclaration_(ProcessJParser.LastFormalDeclaration_Context ctx) {
    return super.visitLastFormalDeclaration_(ctx);
  }

  @Override
  public Object visitBlockExpression(ProcessJParser.BlockExpressionContext ctx) {
    return null;
  }

  @Override
  public RecordTopLevel visitRecordDeclaration(ProcessJParser.RecordDeclarationContext ctx) {
    int modifiers = Opcodes.ACC_PRIVATE;
    if (ctx.modifier() != null) {
      modifiers -= Opcodes.ACC_PRIVATE;
      for (int i = 0; i < ctx.modifier().size(); ++i) {
        modifiers += visitModifier(ctx.modifier(i));
      }
    }
    String name = ctx.Identifier().getText();
    Sequence<TopLevelDeclaration<?>> implementedNames = Sequence.sequenceList();
    if (ctx.extends_() != null) {
      Sequence<Name> _extends = visitExtends(ctx.extends_());
      for (Name n : _extends) {
        TypeDeclarationTopLevel typeDecl = configureNode(new TypeDeclarationTopLevel(), n);
        typeDecl.setQualifier(n);
        implementedNames.add(typeDecl);
      }
    }
    Sequence<FieldDeclaration> fields = visitRecordBody(ctx.recordBody());
    RecordTopLevel recordTopLevel = new RecordTopLevel();
    recordTopLevel.setModifiers(modifiers)
        .setName(name)
        .setImplementedNames(implementedNames)
        .setDeclaredFields(fields);
    return configureNode(recordTopLevel, ctx);
  }

  @Override
  public Sequence<Name> visitExtends(ProcessJParser.ExtendsContext ctx) {
    Sequence<Name> _extends = Sequence.sequenceList();
    ctx.typeVariable().forEach(n -> _extends.add((Name) visit(n)));
    return _extends;
  }

  @Override
  public Sequence<FieldDeclaration> visitRecordBody(ProcessJParser.RecordBodyContext ctx) {
    Sequence<FieldDeclaration> fields = Sequence.sequenceList();
    if (ctx.recordField() != null) {
      ctx.recordField().forEach(f -> fields.addAll(visitRecordField(f)));
    }
    return fields;
  }

  @Override
  public Sequence<FieldDeclaration> visitRecordField(ProcessJParser.RecordFieldContext ctx) {
    Sequence<FieldDeclaration> fields = Sequence.sequenceList();
    Type type = (Type) visit(ctx.type_());
    Sequence<Expression<?>> variables = visitVariableDeclaratorList(ctx.variableDeclaratorList());
    for (Expression<?> expr : variables) {
      if (expr.isVariableExpr()) {
        VariableExpr variableExpr = expr.asVariableExpr();
        FieldDeclaration field = new FieldDeclaration(null, variableExpr.getName());
        if (variableExpr.getASTType() != null) {
          if (variableExpr.getASTType().isArrayNode()) {
            ArrayNode arrayNode = variableExpr.getASTType().asArrayNode();
            arrayNode.getTSType().setComponentType(type);
            field.setASTType(arrayNode);
          }
        } else {
          field.setASTType(createASTType(type));
        }
        fields.add(configureNode(field, variableExpr));
      } else if (expr.isDeclarationExpr()) {
        DeclarationExpr declarationExpr = expr.asDeclarationExpr();
        String name = declarationExpr.getLeftExpression().asVariableExpr().getName();
        FieldDeclaration field = new FieldDeclaration(null, name);
        field.setRightExpression(declarationExpr.getRightExpression());
        field.setASTType(createASTType(type));
        fields.add(configureNode(field, declarationExpr));
      }
    }
    return fields;
  }

  @Override
  public Sequence<Expression<?>> visitVariableDeclaratorList(ProcessJParser.VariableDeclaratorListContext ctx) {
    Sequence<Expression<?>> variables = Sequence.sequenceList();
    ctx.variableDeclarator().forEach(v -> variables.add(visitVariableDeclarator(v)));
    return variables;
  }

  @Override
  public Expression<?> visitVariableDeclarator(ProcessJParser.VariableDeclaratorContext ctx) {
    VariableExpr variableExpr;
    Tuple<?> tuple = visitVariableDeclaratorIdentifier(ctx.variableDeclaratorIdentifier());
    if (tuple.isTuple1()) {
      Tuple1<String> t1 = tuple.asTuple1();
      variableExpr = new VariableExpr().setName(t1.getV1());
    } else {
      Tuple2<String, ArrayType> t2 = tuple.asTuple2();
      ArrayNode arrayNode = configureNode(new ArrayNode(t2.getV2()), t2.getV2());
      variableExpr = new VariableExpr(arrayNode, t2.getV1());
    }
    configureNode(variableExpr, ctx.variableDeclaratorIdentifier());
    if (ctx.variableInitializer() != null) {
      DeclarationExpr declarationExpr = new DeclarationExpr(variableExpr,
          ctx.EQ().getSymbol(), visitVariableInitializer(ctx.variableInitializer()));
      return configureNode(declarationExpr, ctx);
    }
    return configureNode(variableExpr, ctx);
  }

  @Override
  public Tuple<?> visitVariableDeclaratorIdentifier(ProcessJParser.VariableDeclaratorIdentifierContext ctx) {
    String name = ctx.Identifier().getText();
    if (ctx.dims() != null) {
      ArrayType type = visitDims(ctx.dims());
      return Tuple2.tuple(name, type);
    }
    return Tuple1.tuple(name);
  }

  @Override
  public Expression<?> visitVariableInitializer(ProcessJParser.VariableInitializerContext ctx) {
    return null;
  }

  @Override
  public ProtocolTopLevel visitProtocolDeclarationSemi(ProcessJParser.ProtocolDeclarationSemiContext ctx) {
    int modifiers = Opcodes.ACC_PRIVATE;
    if (ctx.modifier() != null) {
      modifiers -= Opcodes.ACC_PRIVATE;
      for (int i = 0; i < ctx.modifier().size(); ++i) {
        modifiers += visitModifier(ctx.modifier(i));
      }
    }
    String name = ctx.Identifier().getText();
    Sequence<TopLevelDeclaration<?>> implementedNames = Sequence.sequenceList();
    if (ctx.extends_() != null) {
      Sequence<Name> _extends = visitExtends(ctx.extends_());
      for (Name n : _extends) {
        TypeDeclarationTopLevel typeDecl = configureNode(new TypeDeclarationTopLevel(), n);
        typeDecl.setQualifier(n);
        implementedNames.add(typeDecl);
      }
    }
    ProtocolTopLevel protocolTopLevel = new ProtocolTopLevel();
    protocolTopLevel.setModifiers(modifiers)
        .setName(name)
        .setImplementedNames(implementedNames);
    return configureNode(protocolTopLevel, ctx);
  }

  @Override
  public ProtocolTopLevel visitProtocolDeclarationWithBody(ProcessJParser.ProtocolDeclarationWithBodyContext ctx) {
    int modifiers = Opcodes.ACC_PRIVATE;
    if (ctx.modifier() != null) {
      modifiers -= Opcodes.ACC_PRIVATE;
      for (int i = 0; i < ctx.modifier().size(); ++i) {
        modifiers += visitModifier(ctx.modifier(i));
      }
    }
    String name = ctx.Identifier().getText();
    Sequence<TopLevelDeclaration<?>> names = Sequence.sequenceList();
    if (ctx.extends_() != null) {
      Sequence<Name> _extends = visitExtends(ctx.extends_());
      for (Name n : _extends) {
        TypeDeclarationTopLevel typeDecl = configureNode(new TypeDeclarationTopLevel(), n);
        typeDecl.setQualifier(n);
        names.add(typeDecl);
      }
    }
    Sequence<ProtocolTagDeclaration> tags = visitProtocolBody(ctx.protocolBody());
    ProtocolTopLevel protocolTopLevel = new ProtocolTopLevel();
    protocolTopLevel.setModifiers(modifiers)
        .setName(name)
        .setImplementedNames(names)
        .setDeclaredTags(tags);
    return configureNode(protocolTopLevel, ctx);
  }

  @Override
  public Sequence<ConstantTopLevel> visitConstantDeclaration(ProcessJParser.ConstantDeclarationContext ctx) {
    int modifiers = Opcodes.ACC_PRIVATE;
    if (ctx.modifier() != null) {
      modifiers -= Opcodes.ACC_PRIVATE;
      for (int i = 0; i < ctx.modifier().size(); ++i) {
        modifiers += visitModifier(ctx.modifier(i));
      }
    }
    ASTType type = visitType_(ctx.type_());
    Sequence<ConstantTopLevel> constantTopLevels = Sequence.sequenceList();
    Sequence<Expression<?>> variables = visitVariableDeclaratorList(ctx.variableDeclaratorList());
    for (Expression<?> expr : variables) {
      if (expr.isVariableExpr()) {
        VariableExpr variableExpr = expr.asVariableExpr();
        ConstantTopLevel constDecl = new ConstantTopLevel();
        constDecl.setModifiers(modifiers);
        constDecl.setName(variableExpr.getName());
        if (variableExpr.getASTType() != null) {
          if (variableExpr.getASTType().isArrayNode()) {
            ArrayNode arrayNode = variableExpr.getASTType().asArrayNode();
            arrayNode.getTSType().setComponentType(type.getTSType());
            constDecl.setASTType(arrayNode);
          }
        } else {
          constDecl.setASTType(type);
        }
        constantTopLevels.add(configureNode(constDecl, variableExpr));
      } else if (expr.isDeclarationExpr()) {
        DeclarationExpr declarationExpr = expr.asDeclarationExpr();
        String name = declarationExpr.getLeftExpression().asVariableExpr().getName();
        ConstantTopLevel constDecl = new ConstantTopLevel();
        constDecl.setName(name);
        constDecl.setRightExpression(declarationExpr.getRightExpression());
        constDecl.setASTType(type);
        constantTopLevels.add(configureNode(constDecl, declarationExpr));
      }
    }
    return constantTopLevels;
  }

  @Override
  public Sequence<ProtocolTagDeclaration> visitProtocolBody(ProcessJParser.ProtocolBodyContext ctx) {
    Sequence<ProtocolTagDeclaration> tags = Sequence.sequenceList();
    ctx.protocolCase().forEach(t -> tags.add(visitProtocolCase(t)));
    return tags;
  }

  @Override
  public ProtocolTagDeclaration visitProtocolCase(ProcessJParser.ProtocolCaseContext ctx) {
    String name = ctx.Identifier().getText();
    Sequence<FieldDeclaration> fields = visitRecordBody(ctx.recordBody());
    ProtocolTagDeclaration protocolTag = new ProtocolTagDeclaration(name, fields);
    return configureNode(protocolTag, ctx);
  }
}
