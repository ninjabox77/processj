package visitor;

import ast.*;
import ast.Package;
import ast.java.FieldDeclaration;
import ast.toplevel.ProcedureTopLevel;
import ast.toplevel.RecordTopLevel;
import ast.types.*;
import misc.ConfigureAST;
import org.objectweb.asm.Opcodes;
import parser.ProcessJBaseVisitor;
import parser.ProcessJParser;
import typesystem.*;

import static misc.ConfigureAST.*;

/**
 * Builds the AST from the parse tree generated by antlr4.
 *
 * @author Ben
 */
public class AstBuilder extends ProcessJBaseVisitor<Object> {

  private ArrayType getParentArray(ArrayType array) {
    while (!array.isOrphan()) {
      array = (ArrayType) array.getParentNode().get();
    }
    return array;
  }

  @Override
  public Object visitInit(ProcessJParser.InitContext ctx) {
    Package packet = visitPackageDeclaration(ctx.packageDeclaration());
    Sequence<Import> imports = Sequence.sequenceList();
    ctx.importDeclaration().forEach(i -> imports.add((Import) visit(i)));
    return null;
  }

  @Override
  public Package visitPackageDeclaration(ProcessJParser.PackageDeclarationContext ctx) {
    Package packet = new Package(ctx.Identifier().getText());
    return configureNode(packet, ctx);
  }

  @Override
  public Name visitPackageAccess(ProcessJParser.PackageAccessContext ctx) {
    String ident = ctx.Identifier(0).getText();
    Name oldName = configureNode(new Name(ident), ctx.Identifier(0));
    for (int i = 1; i < ctx.Identifier().size(); ++i) {
      ident = ctx.Identifier(i).getText();
      Name newName = configureNode(new Name(ident), ctx.Identifier(i));
      newName.setQualifier(oldName);
      oldName = newName;
    }
    return configureNode(oldName, ctx);
  }

  @Override
  public Import visitSingleImportDeclaration(ProcessJParser.SingleImportDeclarationContext ctx) {
    Name name = new Name(ctx.Identifier(0).getText());
    configureNode(name, ctx.Identifier(0));
    Import _import = new Import().setName(name);
    if (ctx.Identifier().size() > 1) {
      _import.setFieldName(ctx.Identifier(1).getText());
    }
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitMultiImportDeclaration(ProcessJParser.MultiImportDeclarationContext ctx) {
    Name name = visitPackageAccess(ctx.packageAccess());
    Import _import = new Import().setName(name);
    if (ctx.Identifier() != null) {
      _import.setFieldName(ctx.Identifier().getText());
    }
    return configureNode(_import, ctx);
  }

  @Override
  public Import visitMultiImportDeclarationStar(ProcessJParser.MultiImportDeclarationStarContext ctx) {
    Name name = visitPackageAccess(ctx.packageAccess());
    Import _import = new Import().setName(name).setStar(true);
    return configureNode(_import, ctx);
  }

  @Override
  public ProcedureTopLevel visitProcedureDeclaration(ProcessJParser.ProcedureDeclarationContext ctx) {
    int modifiers = 0;
    if (ctx.modifier() != null) {
      for (int i = 0; i < ctx.modifier().size(); ++i) {
        modifiers += visitModifier(ctx.modifier(i));
      }
    } else {
      modifiers = Opcodes.ACC_PUBLIC;
    }
    ASTType type = visitType_(ctx.type_());
    String procName = ctx.Identifier().toString();
    return null;
  }

  @Override
  public Integer visitModifier(ProcessJParser.ModifierContext ctx) {
    if (ctx.PRIVATE() != null) {
      return Opcodes.ACC_PRIVATE;
    }
    if (ctx.PROTECTED() != null) {
      return Opcodes.ACC_PROTECTED;
    }
    if (ctx.CONST() != null) {
      return Opcodes.ACC_FINAL;
    }
    if (ctx.NATIVE() != null) {
      return Opcodes.ACC_NATIVE;
    }
    return Opcodes.ACC_PUBLIC;
  }

  @Override
  public ASTType visitType_(ProcessJParser.Type_Context ctx) {
    if (ctx.primitiveType() != null) {
      Primitive type = visitPrimitiveType(ctx.primitiveType());
      return configureNode(new PrimitiveNode(type), ctx);
    } else if (ctx.referenceType() != null) {
      Type type = visitReferenceType(ctx.referenceType());
      if (type.isConstructedType()) {
        Constructed ctr = type.asConstructedType();
        if (ctr.isArrayType()) {
          return configureNode(new ArrayNode(ctr.asArrayType()), ctx);
        } else if (ctr.isChannelType()) {
          return configureNode(new ChannelNode(ctr.asChannelType()), ctx);
        } else if (ctr.isChannelEndType()) {
          return configureNode(new ChannelEndNode(ctr.asChannelEndType()), ctx);
        } else if (ctr.isTypeVariable()) {
          return null; // TODO: what should a type variable return?
        }
      }
    } else if (ctx.classType() != null) {
      // TODO: this is for when a Java class is used
    }
    VoidType type = configureNode(new VoidType(), ctx);
    return configureNode(new VoidNode(type), ctx);
  }

  @Override
  public Primitive visitPrimitiveType(ProcessJParser.PrimitiveTypeContext ctx) {
    if (ctx.numericType() != null) {
      return visitNumericType(ctx.numericType());
    } else if (ctx.BOOLEAN() != null) {
      return configureNode(new BooleanType(), ctx);
    } else if (ctx.STRING() != null) {
      return configureNode(new StringType(), ctx);
    } else if (ctx.BARRIER() != null) {
      return configureNode(new BarrierType(), ctx);
    }
    return configureNode(new TimerType(), ctx);
  }

  @Override
  public Primitive visitNumericType(ProcessJParser.NumericTypeContext ctx) {
    if (ctx.integralType() != null) {
      return visitIntegralType(ctx.integralType());
    }
    return visitFloatingPointType(ctx.floatingPointType());
  }

  @Override
  public Primitive visitIntegralType(ProcessJParser.IntegralTypeContext ctx) {
    if (ctx.BYTE() != null) {
      return configureNode(new ByteType(), ctx);
    } else if (ctx.SHORT() != null) {
      return configureNode(new ShortType(), ctx);
    } else if (ctx.INT() != null) {
      return configureNode(new IntegerType(), ctx);
    } else if (ctx.LONG() != null) {
      return configureNode(new LongType(), ctx);
    }
    return configureNode(new CharType(), ctx);
  }

  @Override
  public Primitive visitFloatingPointType(ProcessJParser.FloatingPointTypeContext ctx) {
    if (ctx.FLOAT() != null) {
      return configureNode(new FloatType(), ctx);
    }
    return configureNode(new DoubleType(), ctx);
  }

  @Override
  public Type visitReferenceType(ProcessJParser.ReferenceTypeContext ctx) {
    if (ctx.arrayType() != null) {
      return configureNode(visitArrayType(ctx.arrayType()), ctx);
    } else if (ctx.channelType() != null) {
      return configureNode((Type) visit(ctx.channelType()), ctx);
    }
    return configureNode((Type) visit(ctx.typeVariable()), ctx);
  }

  @Override
  public ArrayType visitArrayType(ProcessJParser.ArrayTypeContext ctx) {
    ArrayType array = visitDims(ctx.dims());
    if (ctx.primitiveType() != null) {
      Type type = visitPrimitiveType(ctx.primitiveType());
      array.setComponentType(type);
    } else if (ctx.channelType() != null) {
      Type type = (Type) visit(ctx.channelType());
      array.setComponentType(type);
    } else if (ctx.typeVariable() != null) {
      Type type = (Type) visit(ctx.typeVariable());
      array.setComponentType(type);
    }
    return getParentArray(array);
  }

  //
  // we build an array-type in reverse order so that in the body of
  // the caller we can set its component-type; e.g.:
  //
  //    ArrayType(ArrayType(ArrayType(<component-type>)))
  //
  // where component-type can be an atomic or constructed type
  //
  @Override
  public ArrayType visitDims(ProcessJParser.DimsContext ctx) {
    ArrayType outerType = configureNode(new ArrayType(), ctx.LBRACK(0));
    for (int i = 1; i < ctx.LBRACK().size(); ++i) {
      ArrayType innerType = configureNode(new ArrayType(), ctx.LBRACK(i));
      outerType.setComponentType(innerType);
      outerType = innerType;
    }
    return outerType;
  }

  @Override
  public ChannelType visitChannelSharedReadType(ProcessJParser.ChannelSharedReadTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_READ);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedWriteType(ProcessJParser.ChannelSharedWriteTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED_WRITE);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelSharedType(ProcessJParser.ChannelSharedTypeContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelType visitChannelType_(ProcessJParser.ChannelType_Context ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelType chan = new ChannelType(type, ChannelType.NON_SHARED);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotRead(ProcessJParser.ChannelDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public ChannelEndType visitChannelDotWrite(ProcessJParser.ChannelDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public Object visitChannelSharedDotRead(ProcessJParser.ChannelSharedDotReadContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.READ_END);
    return configureNode(chan, ctx);
  }

  @Override
  public Object visitChannelSharedDotWrite(ProcessJParser.ChannelSharedDotWriteContext ctx) {
    Type type = configureNode((Type) visit(ctx.type_()), ctx.type_());
    ChannelEndType chan = new ChannelEndType(type, ChannelEndType.SHARED + ChannelEndType.WRITE_END);
    return configureNode(chan, ctx);
  }

  @Override
  public TypeVariable visitTypeVariableIdentifier(ProcessJParser.TypeVariableIdentifierContext ctx) {
    Name name = configureNode(new Name(ctx.Identifier().getText()), ctx.Identifier());
    return configureNode(new TypeVariable(name), ctx);
  }

  @Override
  public TypeVariable visitTypeVariablePackageDdotIdentifier(ProcessJParser.TypeVariablePackageDdotIdentifierContext ctx) {
    Name name = new Name()
        .setQualifier(visitPackageAccess(ctx.packageAccess()))
        .setIdentifier(ctx.Identifier().getText());
    configureNode(name, ctx.packageAccess());
    return configureNode(new TypeVariable(name), ctx);
  }

//  @Override
//  public TypeVariable visitTypeVariablePackageDotIdentifier(ProcessJParser.TypeVariablePackageDotIdentifierContext ctx) {
//    Name name = new Name().setQualifier(visitPackageAccess(ctx.packageAccess())).setIdentifier(ctx.Identifier().getText());
//    configureNode(name, ctx);
//    return configureNode(new TypeVariable(name), ctx);
//  }


  @Override
  public Object visitFormalDeclaration_(ProcessJParser.FormalDeclaration_Context ctx) {
    return null;
  }

  @Override
  public Object visitLastFormalDeclaration_(ProcessJParser.LastFormalDeclaration_Context ctx) {
    return super.visitLastFormalDeclaration_(ctx);
  }

  @Override
  public Object visitBlockExpression(ProcessJParser.BlockExpressionContext ctx) {
    return null;
  }

  @Override
  public RecordTopLevel visitRecordDeclaration(ProcessJParser.RecordDeclarationContext ctx) {
    int modifiers = 0;
    if (ctx.modifier() != null) {
      for (int i = 0; i < ctx.modifier().size(); ++i) {
        modifiers += visitModifier(ctx.modifier(i));
      }
    } else {
      modifiers = Opcodes.ACC_PUBLIC;
    }
    String name = ctx.Identifier().getText();
    Sequence<Name> _extends;
    if (ctx.extends_() != null) {
      _extends = visitExtends(ctx.extends_());
    }
    return null;
  }

  @Override
  public Sequence<Name> visitExtends(ProcessJParser.ExtendsContext ctx) {
    Sequence<Name> _extends = Sequence.sequenceList();
    ctx.typeVariable().forEach(n -> _extends.add((Name) visit(n)));
    return _extends;
  }

  @Override
  public Sequence<FieldDeclaration> visitRecordBody(ProcessJParser.RecordBodyContext ctx) {
    Sequence<FieldDeclaration> fields = Sequence.sequenceList();
    if (ctx.recordField() != null) {
      ctx.recordField().forEach(f -> fields.add(visitRecordField(f)));
    }
    return fields;
  }

  @Override
  public FieldDeclaration visitRecordField(ProcessJParser.RecordFieldContext ctx) {
    Type type = (Type) visit(ctx.type_());
    return null;
  }

  @Override
  public Object visitVariableDeclaratorList(ProcessJParser.VariableDeclaratorListContext ctx) {
//    ctx.variableDeclarator().forEach(v ->);
    return null;
  }

  @Override
  public Object visitVariableDeclarator(ProcessJParser.VariableDeclaratorContext ctx) {
    return null;
  }

  @Override
  public Object visitVariableDeclaratorIdentifier(ProcessJParser.VariableDeclaratorIdentifierContext ctx) {
    return null;
  }
}
